<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Anti-debugging protection -->
    <!-- <script>
      setInterval(function() {
        debugger;
      }, 100);
    </script> -->
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2H559N5J64"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2H559N5J64');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Idle BTC Miner | GAME</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root { --btc: #f7931a; --bg: #050505; --panel: #111; --green: #00ff88; --red: #ff3344; --border: #222; }
        body { font-family: 'Inter', -apple-system, sans-serif; background: var(--bg); color: #fff; margin: 0; padding: 20px; overflow: hidden; height: 100vh; box-sizing: border-box; }
        
        #main-layout { display: grid; grid-template-columns: 7fr 3fr; gap: 20px; height: calc(100vh - 40px); }
        .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; display: flex; flex-direction: column; padding: 24px; position: relative; overflow: hidden; }

        @media (max-width: 1024px) {
            #main-layout { grid-template-columns: 1fr; gap: 15px; }
            body { padding: 10px; }
        }

        @media (max-width: 768px) {
            body { padding: 6px; margin: 0; height: 100vh; overflow: auto; }
            #main-layout { grid-template-columns: 1fr; gap: 6px; max-height: 100vh; }
            .panel { padding: 8px; margin: 0; display: flex; flex-direction: column; }
            .panel:first-child { overflow-y: auto; flex: 0 0 auto; max-height: 50vh; }
            .panel:last-child { overflow-y: auto; flex: 1; min-height: 0; }
            .upgrade-list { overflow-y: auto !important; }
            .nw-label { font-size: 0.65rem; letter-spacing: 0.5px; }
            .nw-amount { font-size: 1.6rem; margin: 2px 0; }
            .mini-stats { gap: 10px; flex-wrap: wrap; margin-bottom: 6px; }
            .stat-item span { font-size: 0.55rem; }
            .stat-val { font-size: 1.1rem !important; }
            .chart-wrapper { min-height: 150px !important; height: 150px !important; flex: 0 0 150px !important; padding: 6px; display: block; margin-top: 6px; overflow: hidden; }
            /* Keep crypto prices in a compact row on mobile */
            #crypto-prices-flex { gap: 6px !important; flex-wrap: nowrap !important; overflow-x: auto; }
            #crypto-prices-flex > div { flex: 0 0 auto !important; min-width: auto !important; }
            #crypto-prices-flex .stat-val { font-size: 0.9rem !important; }
            #crypto-prices-flex span { font-size: 0.5rem !important; }
            /* Make hashrate display smaller and compact on mobile */
            #hashrate-display { flex-wrap: wrap; gap: 2px !important; margin-bottom: 6px; }
            #hashrate-display > div { padding: 3px 5px !important; flex: 0 1 calc(33.33% - 1.5px) !important; }
            #hashrate-display span { font-size: 0.45rem !important; margin-bottom: 0 !important; line-height: 1; }
            #hashrate-display b { font-size: 0.55rem !important; line-height: 1; }
        }

        @media (max-width: 480px) and (orientation: portrait) {
            body { padding: 5px; margin: 0; height: 100vh; overflow: auto; }
            #main-layout { gap: 5px; max-height: 100vh; }
            .panel { padding: 6px; margin: 0; display: flex; flex-direction: column; }
            .panel:first-child { overflow-y: auto; flex: 0 0 auto; max-height: 45vh; }
            .panel:last-child { overflow-y: auto; flex: 1; min-height: 0; }
            .upgrade-list { overflow-y: auto !important; }
            .nw-label { font-size: 0.6rem; }
            .nw-amount { font-size: 1.5rem; margin: 1px 0; }
            .stat-val { font-size: 0.95rem !important; }
            .chart-wrapper { min-height: 120px !important; height: 120px !important; flex: 0 0 120px !important; display: block; margin-top: 4px; overflow: hidden; }
            /* Keep crypto prices in compact row on small phones */
            #crypto-prices-flex { gap: 4px !important; flex-wrap: nowrap !important; overflow-x: auto; }
            #crypto-prices-flex > div { flex: 0 0 auto !important; min-width: auto !important; padding: 3px !important; }
            #crypto-prices-flex .stat-val { font-size: 0.7rem !important; }
            #crypto-prices-flex span { font-size: 0.4rem !important; }
            /* Make hashrate display even smaller on small phones */
            #hashrate-display { gap: 1px !important; flex-wrap: wrap; margin-bottom: 4px; }
            #hashrate-display > div { padding: 2px 3px !important; flex: 0 1 calc(33.33% - 1px) !important; }
            #hashrate-display span { font-size: 0.4rem !important; margin-bottom: 0px !important; line-height: 1; }
            #hashrate-display b { font-size: 0.5rem !important; line-height: 1; }
        }

            .u-item { padding: 10px; margin-bottom: 8px; }
        }
        
        .nw-label { font-size: 1.2rem; color: #555; text-transform: uppercase; letter-spacing: 3px; font-weight: 700; }
        .nw-amount { 
            font-size: 4.5rem; 
            font-weight: 950; 
            color: var(--green); 
            font-family: monospace; 
            line-height: 1; 
            margin: 8px 0; 
            letter-spacing: -3px; 
            white-space: nowrap;
        }
        .btc-stat { font-size: 2.2rem; color: var(--btc); font-weight: bold; font-family: monospace; border-bottom: 2px solid var(--border); padding-bottom: 12px; margin-bottom: 25px; }

        /* Restoring the 2-column feel for the first two, but allowing the 3rd to be wide */
        .mini-stats { display: flex; justify-content: space-between; gap: 30px; margin-bottom: 15px; }
        .stat-item { flex: 1; }
        .stat-item:last-child { flex: 1.5; } /* Give more room to the long BTC string */
        
        .stat-item span { font-size: 0.9rem; color: #777; text-transform: uppercase; display: block; margin-bottom: 5px; font-weight: 800; }
        
        .stat-val { 
            font-size: 2.8rem !important; /* BACK TO BIG FONT */
            color: #ffffff; 
            font-family: monospace; 
            display: flex; 
            align-items: center; 
            line-height: 1;
            font-weight: 900;
            letter-spacing: -2px;
            white-space: nowrap;
        }

        .chart-wrapper {
            flex: 1;
            min-height: 200px;
            background: #0a0a0a;
            border-radius: 8px;
            border: 1px solid #1a1a1a;
            position: relative;
            margin-top: 10px;
            padding: 10px;
        }

        #nwChart {
            width: 100% !important;
            height: 100% !important;
        }

        .chart-container {
            flex: 1;
            min-height: 0;
            position: relative;
        }

        .tab-buttons { display: flex; gap: 10px; margin-bottom: 10px; }
        .tab-btn { flex: 1; padding: 8px; background: #333; border: 1px solid #444; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 0.85rem; transition: 0.2s; }
        .tab-btn.active { background: transparent; border-width: 2px; }

        .qty-toggle { flex: 1; padding: 5px; background: #1a1a1a; color: #666; border: 2px solid #333; border-radius: 6px; cursor: pointer; font-weight: 800; font-size: 0.7rem; transition: 0.2s; }
        .qty-toggle:hover { background: #222; border-color: #444; color: #888; }
        .qty-toggle.active { background: #222; color: #fff; border-color: #666; box-shadow: 0 0 10px rgba(255, 255, 255, 0.2); }
        .tab-content { display: none; flex-direction: column; min-height: 0; flex: 1; }
        .tab-content.active { display: flex; }

        .mine-btn { background: var(--btc); color: #000; border: none; width: 100%; padding: 12px; font-weight: 900; border-radius: 8px; cursor: pointer; transition: 0.1s; font-size: 0.85rem; margin-bottom: 8px; }
        .upgrade-list { flex: 1; overflow-y: auto; padding-right: 5px; }
        .u-item {
            background: #181818;
            border: 1px solid #252525;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            cursor: pointer;
            width: 100%;
            color: #fff;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .u-item:hover:not(:disabled) {
            border-color: var(--btc) !important;
            box-shadow: 0 0 15px rgba(247, 147, 26, 0.4) !important;
            transition: box-shadow 0.2s ease;
        }

        .mine-btn:hover {
            box-shadow: 0 0 25px rgba(247, 147, 26, 0.6);
            cursor: pointer;
            filter: brightness(1.1);
        }

        .mine-btn:active {
            transform: scale(0.96) translateY(2px);
            box-shadow: 0 0 10px rgba(247, 147, 26, 0.3);
        }

        .mine-btn {
            transition: transform 0.05s, box-shadow 0.2s, filter 0.2s;
        }

        .u-item:disabled {
            opacity: 0.2;
            cursor: not-allowed;
        }

/* Disabled boost buttons styling */
button:disabled {
    cursor: not-allowed !important;
    opacity: 0.5;
}

button:disabled:hover {
    cursor: not-allowed !important;
}

        
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: #333; }

        #price-notif-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 12px;
            min-width: 60px;
            height: 1.2rem;
        }

        .price-notification {
            position: absolute;
            background: transparent;
            border: none;
            padding: 0;
            color: #fff;
            font-weight: bold;
            font-size: 0.75rem;
            animation: fadeSwitch 2.5s ease forwards;
            font-family: monospace;
            white-space: nowrap;
        }

        .price-notification.up { color: #00ff88; }
        .price-notification.down { color: #ff3344; }

        @keyframes fadeSwitch {
            0% { opacity: 1; }
            85% { opacity: 1; }
            100% { opacity: 0; }
        }

        .offline-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #111;
            border: 2px solid #f7931a;
            border-radius: 12px;
            padding: 30px;
            z-index: 2000;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 0 40px rgba(247, 147, 26, 0.3);
            animation: slideUp 0.4s ease;
        }

        .offline-modal h2 {
            color: #f7931a;
            margin: 0 0 15px 0;
            font-size: 1.8rem;
        }

        .offline-modal .earnings {
            font-size: 2.5rem;
            color: #00ff88;
            font-family: monospace;
            font-weight: bold;
            margin: 15px 0;
        }

        .offline-modal .earnings-label {
            color: #888;
            font-size: 0.9rem;
            text-transform: uppercase;
            margin-bottom: 20px;
        }

        .offline-modal .time-offline {
            color: #666;
            font-size: 0.85rem;
            margin-bottom: 20px;
        }

        .offline-modal button {
            background: #f7931a;
            border: none;
            color: #000;
            padding: 10px 30px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }

        .offline-modal button:hover {
            background: #ffaa33;
            transform: scale(1.05);
        }

        .offline-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1999;
            animation: fadeIn 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translate(-50%, -40%); opacity: 0; }
            to { transform: translate(-50%, -50%); opacity: 1; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

    </style>
</head>
<body>

    <div id="main-layout">
        <div class="panel">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                <span class="nw-label">Crypto Portfolio Valuation</span>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button id="mute-btn" style="background: #888; color: white; border: none; padding: 4px 10px; font-weight: 700; border-radius: 4px; cursor: pointer; font-size: 0.55rem;" onclick="toggleMute()">SOUND ON</button>
                    <button style="background: #ff3344; color: white; border: none; padding: 4px 10px; font-weight: 700; border-radius: 4px; cursor: pointer; font-size: 0.55rem;" onclick="resetGame()">RESET SAVE</button>
                    <span style="font-size: 0.6rem; color: #555;">Idle BTC Miner™ 2026 - Aaron Khan</span>
                </div>
            </div>
            <div class="nw-amount" id="nw-val">$0.00</div>

            <!-- Crypto Balances -->
            <div style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px;">
                <div style="font-size: 1.4rem; color: #f7931a; font-weight: bold; font-family: monospace;">₿ <span id="bal-btc">0.00000000</span></div>
                <div style="font-size: 1.4rem; color: #627eea; font-weight: bold; font-family: monospace;">Ξ <span id="bal-eth">0.00000000</span></div>
                <div style="font-size: 1.4rem; color: #c2a633; font-weight: bold; font-family: monospace;">Ð <span id="bal-doge">0.00</span></div>
            </div>

            <div class="mini-stats">
                <div class="stat-item">
                    <span>Hardware Equity</span>
                    <b class="stat-val" id="asset-usd">$0</b>
                </div>
            </div>

            <!-- Hashrate Display -->
            <div id="hashrate-display" style="display: flex; gap: 6px; margin-bottom: 0.1px; justify-content: flex-end;">
                <div style="padding: 9px 15px; background: rgba(0,0,0,0.3); border-radius: 4px; border: 1px solid #222;">
                    <span style="font-size: 0.75rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 3px; font-weight: 800;">TIME THIS SESSION</span>
                    <b style="font-size: 1.1rem; color: #ffffff; font-family: monospace; font-weight: 900; white-space: nowrap;" id="session-time">0m 0s</b>
                </div>
                <div style="padding: 9px 15px; background: rgba(0,0,0,0.3); border-radius: 4px; border: 1px solid #222;">
                    <span style="font-size: 0.75rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 3px; font-weight: 800;">LIFETIME EARNINGS</span>
                    <b style="font-size: 1.1rem; color: #00ff88; font-family: monospace; font-weight: 900; white-space: nowrap;" id="session-earnings">₿ 0.00000000</b>
                </div>
                <div style="padding: 9px 15px; background: rgba(0,0,0,0.3); border-radius: 4px; border: 1px solid #222;">
                    <span style="font-size: 0.75rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 3px; font-weight: 800;">BTC HASHRATE</span>
                    <b style="font-size: 1.1rem; color: #f7931a; font-family: monospace; font-weight: 900; white-space: nowrap;" id="yield-btc">0.00000000/s</b>
                </div>
                <div style="padding: 9px 15px; background: rgba(0,0,0,0.3); border-radius: 4px; border: 1px solid #222;">
                    <span style="font-size: 0.75rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 3px; font-weight: 800;">ETH HASHRATE</span>
                    <b style="font-size: 1.1rem; color: #627eea; font-family: monospace; font-weight: 900; white-space: nowrap;" id="yield-eth">0.00000000/s</b>
                </div>
                <div style="padding: 9px 15px; background: rgba(0,0,0,0.3); border-radius: 4px; border: 1px solid #222;">
                    <span style="font-size: 0.75rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 3px; font-weight: 800;">DOGE HASHRATE</span>
                    <b style="font-size: 1.1rem; color: #c2a633; font-family: monospace; font-weight: 900; white-space: nowrap;" id="yield-doge">0.00000000/s</b>
                </div>
            </div>

            <!-- Crypto Prices -->
            <div style="margin-top: 20px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 8px; border: 1px solid #222;">
                <span style="font-size: 0.85rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 8px;">Crypto Prices (Virtual)</span>
                <div id="crypto-prices-flex" style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <div style="flex: 1; min-width: 120px;">
                        <div style="font-size: 0.65rem; color: #f7931a; font-weight: 800;">BITCOIN</div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <b class="stat-val" id="btc-price" style="font-size: 1.4rem;">$100,000</b>
                            <span id="btc-indicator" style="font-size: 1.2rem; font-weight: bold; min-width: 20px;"></span>
                            <span id="btc-change" style="font-size: 0.9rem; font-weight: bold; min-width: 50px;"></span>
                        </div>
                    </div>
                    <div style="flex: 1; min-width: 120px;">
                        <div style="font-size: 0.65rem; color: #627eea; font-weight: 800;">ETHEREUM</div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <b class="stat-val" id="eth-price" style="font-size: 1.4rem;">$3,500</b>
                            <span id="eth-indicator" style="font-size: 1.2rem; font-weight: bold; min-width: 20px;"></span>
                            <span id="eth-change" style="font-size: 0.9rem; font-weight: bold; min-width: 50px;"></span>
                        </div>
                    </div>
                    <div style="flex: 1; min-width: 120px;">
                        <div style="font-size: 0.65rem; color: #c2a633; font-weight: 800;">DOGECOIN</div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <b class="stat-val" id="doge-price" style="font-size: 1.4rem;">$0.25</b>
                            <span id="doge-indicator" style="font-size: 1.2rem; font-weight: bold; min-width: 20px;"></span>
                            <span id="doge-change" style="font-size: 0.9rem; font-weight: bold; min-width: 50px;"></span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="chart-wrapper" style="position: relative; display: block;">
                <canvas id="nwChart" style="width: 100% !important; height: 100% !important; display: block;"></canvas>
            </div>
        </div>

        <div class="panel" style="display: flex; flex-direction: column; min-height: 0;">
            <button class="mine-btn" onclick="manualHash()">MANUAL BTC HASH<br>
                <span style="font-size: 0.8rem; font-weight: normal; opacity: 0.7;">+0.00000250 ₿</span>
            </button>
            <button class="mine-btn" style="background: #627eea; padding: 8px;" onclick="manualEthHash()">MANUAL ETH HASH<br>
                <span style="font-size: 0.8rem; font-weight: normal; opacity: 0.7;">+0.00007143 Ξ</span>
            </button>
            <button class="mine-btn" style="background: #c2a633; padding: 8px;" onclick="manualDogeHash()">MANUAL DOGE HASH<br>
                <span style="font-size: 0.8rem; font-weight: normal; opacity: 0.7;">+1.00000000 Ð</span>
            </button>
            <button id="autoclicker-btn" style="background: #666; color: white; border: none; width: 100%; padding: 8px; font-weight: 700; border-radius: 10px; cursor: pointer; margin-bottom: 8px; font-size: 0.75rem;" onclick="startAutoClicker()">AUTO CLICKER • 5 clicks/sec • 30s • 5m cooldown</button>

            <!-- Power Status Bar -->
            <div style="padding: 8px; background: rgba(0,0,0,0.3); border-radius: 8px; border: 1px solid #222; margin-bottom: 8px;">
                <div style="display: flex; gap: 8px; align-items: center; justify-content: space-between;">
                    <div style="flex: 1;">
                        <span style="font-size: 0.65rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 2px;">Power Status</span>
                        <div style="font-size: 0.65rem; color: #00ff88; font-family: monospace; font-weight: 900;" id="power-used">0W / 0W</div>
                        <div id="power-bar" style="height: 6px; background: #222; border-radius: 3px; margin-top: 2px;">
                            <div id="power-bar-fill" style="height: 100%; background: #00ff88; border-radius: 3px; width: 0%;"></div>
                        </div>
                    </div>
                    <button class="tab-btn" onclick="switchTab('power')" style="border-color: #00ff88; color: #00ff88; padding: 6px 12px; white-space: nowrap;">POWER</button>
                </div>
            </div>

            <!-- Dollar Balance Display -->
            <div style="padding: 6px; background: rgba(0,255,136,0.1); border-radius: 8px; border: 2px solid #00ff88; margin-bottom: 8px; text-align: center;">
                <span style="font-size: 0.6rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 1px; font-weight: 800;">Cash Balance</span>
                <b style="font-size: 1.5rem; color: #00ff88; font-family: monospace; font-weight: 900;" id="dollar-balance">$0</b>
            </div>

            <!-- Tab Buttons -->
            <div class="tab-buttons" style="margin-bottom: 6px;">
                <button class="tab-btn active" onclick="switchTab('btc-mining')" style="border-color: #f7931a; color: #f7931a;">BTC</button>
                <button class="tab-btn" onclick="switchTab('eth-mining')" style="border-color: #627eea; color: #627eea;">ETH</button>
                <button class="tab-btn" onclick="switchTab('doge-mining')" style="border-color: #c2a633; color: #c2a633;">DOGE</button>
            </div>
            <div class="tab-buttons">
                <button class="tab-btn" onclick="switchTab('market')" style="border-color: #00ff88; color: #00ff88;">CRYPTO EXCHANGE</button>
            </div>

            <!-- BTC Mining Tab -->
            <div id="btc-mining-tab" class="tab-content active" style="flex-direction: column; min-height: 0; flex: 1;">
                <!-- Buy Quantity Toggle -->
                <div style="margin-bottom: 10px;">
                    <span style="font-size: 0.7rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px; font-weight: 800;">Purchase Amount</span>
                    <div style="display: flex; gap: 6px;">
                        <button id="qty-toggle-1" class="qty-toggle active" onclick="setBuyQuantity(1)" style="border-color: #888; color: #888;">1x</button>
                        <button id="qty-toggle-2" class="qty-toggle" onclick="setBuyQuantity(2)" style="border-color: #888; color: #888;">2x</button>
                        <button id="qty-toggle-5" class="qty-toggle" onclick="setBuyQuantity(5)" style="border-color: #888; color: #888;">5x</button>
                        <button id="qty-toggle-10" class="qty-toggle" onclick="setBuyQuantity(10)" style="border-color: #888; color: #888;">10x</button>
                    </div>
                </div>
                <div class="upgrade-list" id="btc-shop" style="flex: 1; min-height: 0; overflow-y: auto;"></div>
            </div>

            <!-- ETH Mining Tab -->
            <div id="eth-mining-tab" class="tab-content" style="flex-direction: column; min-height: 0; flex: 1;">
                <!-- Buy Quantity Toggle -->
                <div style="margin-bottom: 10px;">
                    <span style="font-size: 0.7rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px; font-weight: 800;">Purchase Amount</span>
                    <div style="display: flex; gap: 6px;">
                        <button id="eth-qty-toggle-1" class="qty-toggle active" onclick="setBuyQuantity(1)" style="border-color: #888; color: #888;">1x</button>
                        <button id="eth-qty-toggle-2" class="qty-toggle" onclick="setBuyQuantity(2)" style="border-color: #888; color: #888;">2x</button>
                        <button id="eth-qty-toggle-5" class="qty-toggle" onclick="setBuyQuantity(5)" style="border-color: #888; color: #888;">5x</button>
                        <button id="eth-qty-toggle-10" class="qty-toggle" onclick="setBuyQuantity(10)" style="border-color: #888; color: #888;">10x</button>
                    </div>
                </div>
                <div class="upgrade-list" id="eth-shop" style="flex: 1; min-height: 0; overflow-y: auto;"></div>
            </div>

            <!-- DOGE Mining Tab -->
            <div id="doge-mining-tab" class="tab-content" style="flex-direction: column; min-height: 0; flex: 1;">
                <!-- Buy Quantity Toggle -->
                <div style="margin-bottom: 10px;">
                    <span style="font-size: 0.7rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px; font-weight: 800;">Purchase Amount</span>
                    <div style="display: flex; gap: 6px;">
                        <button id="doge-qty-toggle-1" class="qty-toggle active" onclick="setBuyQuantity(1)" style="border-color: #888; color: #888;">1x</button>
                        <button id="doge-qty-toggle-2" class="qty-toggle" onclick="setBuyQuantity(2)" style="border-color: #888; color: #888;">2x</button>
                        <button id="doge-qty-toggle-5" class="qty-toggle" onclick="setBuyQuantity(5)" style="border-color: #888; color: #888;">5x</button>
                        <button id="doge-qty-toggle-10" class="qty-toggle" onclick="setBuyQuantity(10)" style="border-color: #888; color: #888;">10x</button>
                    </div>
                </div>
                <div class="upgrade-list" id="doge-shop" style="flex: 1; min-height: 0; overflow-y: auto;"></div>
            </div>

            <!-- Power Tab -->
            <div id="power-tab" class="tab-content" style="flex-direction: column; min-height: 0; flex: 1;">
                <!-- Buy Quantity Toggle -->
                <div style="margin-bottom: 10px;">
                    <span style="font-size: 0.7rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px; font-weight: 800;">Purchase Amount</span>
                    <div style="display: flex; gap: 6px;">
                        <button class="qty-toggle active" onclick="setBuyQuantity(1)" style="border-color: #888; color: #888;">1x</button>
                        <button class="qty-toggle" onclick="setBuyQuantity(2)" style="border-color: #888; color: #888;">2x</button>
                        <button class="qty-toggle" onclick="setBuyQuantity(5)" style="border-color: #888; color: #888;">5x</button>
                        <button class="qty-toggle" onclick="setBuyQuantity(10)" style="border-color: #888; color: #888;">10x</button>
                    </div>
                </div>
                <div class="upgrade-list" id="power-shop" style="flex: 1; min-height: 0; overflow-y: auto;"></div>
            </div>

            <!-- Market Tab -->
            <div id="market-tab" class="tab-content" style="flex-direction: column; min-height: 0; flex: 1;">
                <div class="upgrade-list" style="flex: 1; min-height: 0; overflow-y: auto; padding: 10px;">
                    <div style="margin-bottom: 15px;">
                        <h3 style="color: #00ff88; margin: 0 0 10px 0; font-size: 1.2rem;">Sell Crypto for Cash</h3>
                        <p style="color: #888; font-size: 0.75rem; margin: 0;">Convert your mined cryptocurrency to dollars to purchase upgrades</p>
                    </div>

                    <!-- BTC Sell -->
                    <div style="background: rgba(247, 147, 26, 0.1); border: 1px solid #f7931a; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="color: #f7931a; font-weight: 800; font-size: 1.1rem;">₿ Bitcoin</span>
                            <span style="color: #888; font-size: 0.8rem;">$<span id="market-btc-price">100,000</span> each</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px;">
                            <button onclick="sellBTC(0.001)" style="background: #f7931a; color: #000; border: none; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem;">SELL 0.001</button>
                            <button onclick="sellBTC(0.01)" style="background: #f7931a; color: #000; border: none; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem;">SELL 0.01</button>
                            <button onclick="sellBTC(0.1)" style="background: #f7931a; color: #000; border: none; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem;">SELL 0.1</button>
                            <button onclick="sellBTC(1)" style="background: #f7931a; color: #000; border: none; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem;">SELL 1</button>
                        </div>
                        <button onclick="sellAllBTC()" style="background: #333; color: #f7931a; border: 1px solid #f7931a; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem; width: 100%; margin-top: 6px;">SELL ALL</button>
                    </div>

                    <!-- ETH Sell -->
                    <div style="background: rgba(98, 126, 234, 0.1); border: 1px solid #627eea; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="color: #627eea; font-weight: 800; font-size: 1.1rem;">Ξ Ethereum</span>
                            <span style="color: #888; font-size: 0.8rem;">$<span id="market-eth-price">3,500</span> each</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px;">
                            <button onclick="sellETH(0.01)" style="background: #627eea; color: #000; border: none; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem;">SELL 0.01</button>
                            <button onclick="sellETH(0.1)" style="background: #627eea; color: #000; border: none; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem;">SELL 0.1</button>
                            <button onclick="sellETH(1)" style="background: #627eea; color: #000; border: none; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem;">SELL 1</button>
                            <button onclick="sellETH(10)" style="background: #627eea; color: #000; border: none; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem;">SELL 10</button>
                        </div>
                        <button onclick="sellAllETH()" style="background: #333; color: #627eea; border: 1px solid #627eea; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem; width: 100%; margin-top: 6px;">SELL ALL</button>
                    </div>

                    <!-- DOGE Sell -->
                    <div style="background: rgba(194, 166, 51, 0.1); border: 1px solid #c2a633; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="color: #c2a633; font-weight: 800; font-size: 1.1rem;">Ð Dogecoin</span>
                            <span style="color: #888; font-size: 0.8rem;">$<span id="market-doge-price">0.25</span> each</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px;">
                            <button onclick="sellDOGE(1)" style="background: #c2a633; color: #000; border: none; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem;">SELL 1</button>
                            <button onclick="sellDOGE(10)" style="background: #c2a633; color: #000; border: none; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem;">SELL 10</button>
                            <button onclick="sellDOGE(100)" style="background: #c2a633; color: #000; border: none; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem;">SELL 100</button>
                            <button onclick="sellDOGE(1000)" style="background: #c2a633; color: #000; border: none; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem;">SELL 1000</button>
                        </div>
                        <button onclick="sellAllDOGE()" style="background: #333; color: #c2a633; border: 1px solid #c2a633; padding: 8px; border-radius: 6px; font-weight: 800; cursor: pointer; font-size: 0.75rem; width: 100%; margin-top: 6px;">SELL ALL</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>

    // Bitcoin
    let btcPrice = 100000; // Set manually each day - everyone starts at 100k
    let btcBalance = 0;
    let btcLifetime = 0;
    let btcPerSec = 0;
    let btcClickValue = 0.00000250;
    const BTC_MIN_PRICE = 50000;
    const BTC_MAX_PRICE = 200000;

    // Ethereum
    let ethPrice = 3500; // Starting ETH price
    let ethBalance = 0;
    let ethLifetime = 0;
    let ethPerSec = 0;
    let ethClickValue = 0.00007143; // $0.25 worth at $3500/ETH
    const ETH_MIN_PRICE = 1500;
    const ETH_MAX_PRICE = 8000;

    // Dogecoin
    let dogePrice = 0.25; // Starting DOGE price
    let dogeBalance = 0;
    let dogeLifetime = 0;
    let dogePerSec = 0;
    let dogeClickValue = 1.00000000; // $0.25 worth at $0.25/DOGE
    const DOGE_MIN_PRICE = 0.05;
    const DOGE_MAX_PRICE = 2.00;

    let hardwareEquity = 0;
    let dollarBalance = 0; // USD balance from selling crypto
    let lastTickTime = Date.now();
    let lastPriceUpdateTime = 0; // Track when price was last updated
    let manualHashClickTime = 0;
    let manualHashCooldownEnd = 0;
    let clickTimestamps = [];
    let priceSwingsStarted = false; // Flag to prevent starting price swings multiple times

    // Session tracking
    let sessionStartTime = Date.now();
    let sessionStartBalance = 0;
    let sessionStartNetWorth = 0;
    let sessionEarnings = 0;
    let lifetimeEarnings = 0; // Lifetime total - only ever increases, never decreases
    let previousPortfolioValue = 0; // Track previous value to detect increases

    // Buy quantity setting
    let buyQuantity = 1;

    // Chart history tracking
    let chartHistory = [];
    let chartTimestamps = []; // Track when each data point was added
    let lastChartUpdateTime = Date.now();
    let chartStartTime = Date.now();

    // Power system
    let totalPowerAvailable = 0; // Total watts available
    let totalPowerUsed = 0; // Total watts being used
    const powerUpgrades = [
        { id: 0, name: "Regulated PSU", baseUsd: 50, basePower: 100 },
        { id: 1, name: "High-Efficiency PSU", baseUsd: 200, basePower: 500 },
        { id: 2, name: "Server-Grade PSU", baseUsd: 1000, basePower: 2000 },
        { id: 3, name: "Mining Power Distribution Unit", baseUsd: 5000, basePower: 10000 },
        { id: 4, name: "Modular Data Center Power System", baseUsd: 25000, basePower: 50000 },
        { id: 5, name: "Dedicated Substation Power Unit", baseUsd: 100000, basePower: 200000 }
    ].map(u => ({ ...u, level: 0, currentUsd: u.baseUsd, currentPower: 0 }));

    // Power requirements for mining equipment (in watts)
    const equipmentPowerReqs = {
        0: 0, // Manual hash uses no power
        1: 2.5, // USB Miner
        2: 75, // GTX 1660
        3: 450, // RTX 5090
        4: 1200, // ASIC
        5: 3500, // Liquid ASIC
        6: 12000, // Container
        7: 45000, // Geothermal Farm
        8: 300000, // Data Center
        9: 1500000, // Orbital
        10: 5000000 // Quantum
    };

    // Show price change notification
    // Track timeout IDs for each crypto to clear previous timers
    let indicatorTimeouts = { btc: null, eth: null, doge: null };

    function updatePriceIndicator(crypto, oldPrice, newPrice) {
        const change = newPrice - oldPrice;
        const changePercent = ((change / oldPrice) * 100).toFixed(2);
        const isUp = change >= 0;
        const indicatorId = crypto + '-indicator';
        const changeId = crypto + '-change';
        const indicator = document.getElementById(indicatorId);
        const changeDisplay = document.getElementById(changeId);

        // Clear previous timeout if exists
        if (indicatorTimeouts[crypto]) {
            clearTimeout(indicatorTimeouts[crypto]);
        }

        if (indicator && changeDisplay) {
            indicator.textContent = isUp ? '▲' : '▼';
            indicator.style.color = isUp ? '#00ff88' : '#ff3344';
            changeDisplay.textContent = (isUp ? '+' : '') + changePercent + '%';
            changeDisplay.style.color = isUp ? '#00ff88' : '#ff3344';

            // Set timeout to clear both after 0.8 seconds
            indicatorTimeouts[crypto] = setTimeout(() => {
                indicator.textContent = '';
                changeDisplay.textContent = '';
                indicatorTimeouts[crypto] = null;
            }, 800);
        }
    }

    // BTC tiny swings: ±0.05%-0.1% every 2 seconds with mean reversion
    function btcTinySwing() {
        setTimeout(() => {
            let oldBtcPrice = btcPrice;
            const btcTarget = 100000;
            const distanceFromTarget = Math.abs(btcPrice - btcTarget);
            const maxDistance = Math.abs(BTC_MAX_PRICE - btcTarget);
            const distancePercent = distanceFromTarget / maxDistance;

            let movePercent = (Math.random() * 0.0005) + 0.0005;
            let direction;

            if (Math.random() < (0.3 + distancePercent * 0.4)) {
                direction = btcPrice > btcTarget ? -1 : 1;
            } else {
                direction = Math.random() > 0.5 ? 1 : -1;
            }

            let newBtcPrice = oldBtcPrice * (1 + (direction * movePercent));
            btcPrice = Math.max(BTC_MIN_PRICE, Math.min(BTC_MAX_PRICE, newBtcPrice));
            updatePriceIndicator('btc', oldBtcPrice, btcPrice);
            updateUI();
            btcTinySwing();
        }, 2000);
    }

    // BTC frequent swings: ±0.1%-1% every 2-60 seconds randomly with mean reversion
    function btcFrequentSwing() {
        let randomInterval = (Math.random() * (60000 - 2000)) + 2000; // 2-60 seconds
        setTimeout(() => {
            let movePercent = (Math.random() * 0.009) + 0.001; // 0.1% to 1%
            let oldBtcPrice = btcPrice;
            const btcTarget = 100000;
            const distanceFromTarget = Math.abs(btcPrice - btcTarget);
            const maxDistance = Math.abs(BTC_MAX_PRICE - btcTarget);
            const distancePercent = distanceFromTarget / maxDistance; // 0 to 1

            // 60% + up to 30% more chance to revert when far from target
            let newBtcPrice = oldBtcPrice * (1 + movePercent);
            if (Math.random() < (0.6 + distancePercent * 0.3)) {
                const targetPrice = 100000;
                const diff = targetPrice - oldBtcPrice;
                newBtcPrice = oldBtcPrice + (diff * 0.02);
            } else {
                let direction = Math.random() > 0.5 ? 1 : -1;
                newBtcPrice = oldBtcPrice * (1 + (direction * movePercent));
            }
            btcPrice = Math.max(BTC_MIN_PRICE, Math.min(BTC_MAX_PRICE, newBtcPrice));
            updatePriceIndicator('btc', oldBtcPrice, btcPrice);
            updateUI();
            btcFrequentSwing();
        }, randomInterval);
    }

    // ETH tiny swings: ±0.05%-0.1% every 2.3 seconds with mean reversion
    function ethTinySwing() {
        setTimeout(() => {
            let oldEthPrice = ethPrice;
            const ethTarget = 3500;
            const distanceFromTarget = Math.abs(ethPrice - ethTarget);
            const maxDistance = Math.abs(ETH_MAX_PRICE - ethTarget);
            const distancePercent = distanceFromTarget / maxDistance;

            let movePercent = (Math.random() * 0.0005) + 0.0005;
            let direction;

            if (Math.random() < (0.3 + distancePercent * 0.4)) {
                direction = ethPrice > ethTarget ? -1 : 1;
            } else {
                direction = Math.random() > 0.5 ? 1 : -1;
            }

            let newEthPrice = oldEthPrice * (1 + (direction * movePercent));
            ethPrice = Math.max(ETH_MIN_PRICE, Math.min(ETH_MAX_PRICE, newEthPrice));
            updatePriceIndicator('eth', oldEthPrice, ethPrice);
            updateUI();
            ethTinySwing();
        }, 2300);
    }

    // ETH frequent swings: ±0.1%-1.2% every 3-75 seconds randomly with mean reversion
    function ethFrequentSwing() {
        let randomInterval = (Math.random() * (75000 - 3000)) + 3000; // 3-75 seconds
        setTimeout(() => {
            let movePercent = (Math.random() * 0.011) + 0.001; // 0.1% to 1.2%
            let oldEthPrice = ethPrice;
            const ethTarget = 3500;
            const distanceFromTarget = Math.abs(ethPrice - ethTarget);
            const maxDistance = Math.abs(ETH_MAX_PRICE - ethTarget);
            const distancePercent = distanceFromTarget / maxDistance; // 0 to 1

            let newEthPrice = oldEthPrice * (1 + movePercent);
            if (Math.random() < (0.6 + distancePercent * 0.3)) {
                const targetPrice = 3500;
                const diff = targetPrice - oldEthPrice;
                newEthPrice = oldEthPrice + (diff * 0.02);
            } else {
                let direction = Math.random() > 0.5 ? 1 : -1;
                newEthPrice = oldEthPrice * (1 + (direction * movePercent));
            }
            ethPrice = Math.max(ETH_MIN_PRICE, Math.min(ETH_MAX_PRICE, newEthPrice));
            updatePriceIndicator('eth', oldEthPrice, ethPrice);
            updateUI();
            ethFrequentSwing();
        }, randomInterval);
    }

    // DOGE tiny swings: ±0.05%-0.15% every 2.7 seconds with mean reversion (more volatile)
    function dogeTinySwing() {
        setTimeout(() => {
            let oldDogePrice = dogePrice;
            const dogeTarget = 0.25;
            const distanceFromTarget = Math.abs(dogePrice - dogeTarget);
            const maxDistance = Math.abs(DOGE_MAX_PRICE - dogeTarget);
            const distancePercent = distanceFromTarget / maxDistance;

            let movePercent = (Math.random() * 0.001) + 0.0005;
            let direction;

            if (Math.random() < (0.3 + distancePercent * 0.4)) {
                direction = dogePrice > dogeTarget ? -1 : 1;
            } else {
                direction = Math.random() > 0.5 ? 1 : -1;
            }

            let newDogePrice = oldDogePrice * (1 + (direction * movePercent * 1.5));
            dogePrice = Math.max(DOGE_MIN_PRICE, Math.min(DOGE_MAX_PRICE, newDogePrice));
            updatePriceIndicator('doge', oldDogePrice, dogePrice);
            updateUI();
            dogeTinySwing();
        }, 2700);
    }

    // DOGE frequent swings: ±0.15%-1.8% every 2-45 seconds randomly (more volatile) with mean reversion
    function dogeFrequentSwing() {
        let randomInterval = (Math.random() * (45000 - 2000)) + 2000; // 2-45 seconds
        setTimeout(() => {
            let movePercent = (Math.random() * 0.0165) + 0.0015; // 0.15% to 1.8%
            let oldDogePrice = dogePrice;
            const dogeTarget = 0.25;
            const distanceFromTarget = Math.abs(dogePrice - dogeTarget);
            const maxDistance = Math.abs(DOGE_MAX_PRICE - dogeTarget);
            const distancePercent = distanceFromTarget / maxDistance; // 0 to 1

            let newDogePrice = oldDogePrice * (1 + movePercent * 1.5);
            if (Math.random() < (0.6 + distancePercent * 0.3)) {
                const targetPrice = 0.25;
                const diff = targetPrice - oldDogePrice;
                newDogePrice = oldDogePrice + (diff * 0.02);
            } else {
                let direction = Math.random() > 0.5 ? 1 : -1;
                newDogePrice = oldDogePrice * (1 + (direction * movePercent * 1.5));
            }
            dogePrice = Math.max(DOGE_MIN_PRICE, Math.min(DOGE_MAX_PRICE, newDogePrice));
            updatePriceIndicator('doge', oldDogePrice, dogePrice);
            updateUI();
            dogeFrequentSwing();
        }, randomInterval);
    }

    // BTC occasional big swings: ±2.5%-10% every 5 to 10 minutes
    function btcBigSwing() {
        let nextBigSwing = (Math.random() * (600000 - 300000)) + 300000;
        setTimeout(() => {
            let movePercent = (Math.random() * 0.075) + 0.025;
            let direction = Math.random() > 0.5 ? 1 : -1;
            let move = direction * movePercent;
            let oldBtcPrice = btcPrice;
            btcPrice = Math.max(BTC_MIN_PRICE, Math.min(BTC_MAX_PRICE, btcPrice * (1 + move)));
            updatePriceIndicator('btc', oldBtcPrice, btcPrice);
            updateUI();
            btcBigSwing();
        }, nextBigSwing);
    }

    // ETH occasional big swings: ±2.5%-12% every 4 to 12 minutes (more volatile than BTC)
    function ethBigSwing() {
        let nextBigSwing = (Math.random() * (720000 - 240000)) + 240000;
        setTimeout(() => {
            let movePercent = (Math.random() * 0.095) + 0.025; // Slightly more volatile
            let direction = Math.random() > 0.5 ? 1 : -1;
            let move = direction * movePercent;
            let oldEthPrice = ethPrice;
            ethPrice = Math.max(ETH_MIN_PRICE, Math.min(ETH_MAX_PRICE, ethPrice * (1 + move)));
            updatePriceIndicator('eth', oldEthPrice, ethPrice);
            updateUI();
            ethBigSwing();
        }, nextBigSwing);
    }

    // DOGE occasional big swings: ±3%-18% every 3 to 8 minutes (much more volatile)
    function dogeBigSwing() {
        let nextBigSwing = (Math.random() * (480000 - 180000)) + 180000;
        setTimeout(() => {
            let movePercent = (Math.random() * 0.15) + 0.03; // 3% to 18%
            let direction = Math.random() > 0.5 ? 1 : -1;
            let move = direction * movePercent;
            let oldDogePrice = dogePrice;
            dogePrice = Math.max(DOGE_MIN_PRICE, Math.min(DOGE_MAX_PRICE, dogePrice * (1 + move * 1.8)));
            updatePriceIndicator('doge', oldDogePrice, dogePrice);
            updateUI();
            dogeBigSwing();
        }, nextBigSwing);
    }

    // Sound effects using Web Audio API
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    function playClickSound() {
        if (isMuted) return;
        const now = audioContext.currentTime;
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain);
        gain.connect(audioContext.destination);

        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
        osc.type = 'sine';

        gain.gain.setValueAtTime(0.05, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

        osc.start(now);
        osc.stop(now + 0.1);
    }

    function playUpgradeSound() {
        if (isMuted) return;
        const now = audioContext.currentTime;
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain);
        gain.connect(audioContext.destination);

        osc.frequency.setValueAtTime(500, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
        osc.type = 'square';

        gain.gain.setValueAtTime(0.04, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

        osc.start(now);
        osc.stop(now + 0.2);
    }

    // Bitcoin mining upgrades
    const btcUpgrades = [
	{ id: 0, name: "Manual Hash Upgrade", baseUsd: 5, baseYield: 0, isClickUpgrade: true, clickIncrease: 0.00000050 },
        { id: 1, name: "USB Miner", baseUsd: 5, baseYield: 0.000000115 },
        { id: 2, name: "GTX 1660 Super", baseUsd: 100, baseYield: 0.0000007 },
        { id: 3, name: "RTX 5090 Rig", baseUsd: 3000, baseYield: 0.000015 },
        { id: 4, name: "ASIC Mining Unit", baseUsd: 7500, baseYield: 0.000085 },
        { id: 5, name: "Liquid ASIC Rig", baseUsd: 28000, baseYield: 0.00045 },
        { id: 6, name: "Mobile Mining Container", baseUsd: 110000, baseYield: 0.0032 },
        { id: 7, name: "Geothermal Mining Farm", baseUsd: 680000, baseYield: 0.045 },
        { id: 8, name: "Data Center Facility", baseUsd: 5200000, baseYield: 0.62 },
        { id: 9, name: "Orbital Data Relay", baseUsd: 35000000, baseYield: 5.8 },
        { id: 10, name: "Quantum Computer", baseUsd: 500000000, baseYield: 125.0 }
    ].map(u => ({ ...u, level: 0, currentUsd: u.baseUsd, currentYield: 0, boostCost: u.baseUsd * 0.5, boostLevel: 0 }));

    // Ethereum mining upgrades
    const ethUpgrades = [
	{ id: 0, name: "Manual ETH Mining", baseUsd: 5, baseYield: 0, isClickUpgrade: true, clickIncrease: 0.00010000 },
        { id: 1, name: "Single GPU Rig", baseUsd: 8, baseYield: 0.00002500 },
        { id: 2, name: "RTX 4090 Miner", baseUsd: 150, baseYield: 0.00015000 },
        { id: 3, name: "8-GPU Mining Rig", baseUsd: 4500, baseYield: 0.00325000 },
        { id: 4, name: "Professional ETH Farm", baseUsd: 12000, baseYield: 0.01800000 },
        { id: 5, name: "Staking Validator Node", baseUsd: 40000, baseYield: 0.09500000 },
        { id: 6, name: "Multi-Validator Farm", baseUsd: 175000, baseYield: 0.68000000 },
        { id: 7, name: "ETH Mining Complex", baseUsd: 950000, baseYield: 9.50000000 },
        { id: 8, name: "Enterprise Staking Pool", baseUsd: 7500000, baseYield: 132.00000000 },
        { id: 9, name: "Layer 2 Validation Network", baseUsd: 52000000, baseYield: 1230.00000000 },
        { id: 10, name: "Ethereum Foundation Node", baseUsd: 700000000, baseYield: 26500.00000000 }
    ].map(u => ({ ...u, level: 0, currentUsd: u.baseUsd, currentYield: 0, boostCost: u.baseUsd * 0.5, boostLevel: 0 }));

    // Dogecoin mining upgrades
    const dogeUpgrades = [
	{ id: 0, name: "Manual DOGE Mining", baseUsd: 3, baseYield: 0, isClickUpgrade: true, clickIncrease: 0.50 },
        { id: 1, name: "Basic Scrypt Miner", baseUsd: 3, baseYield: 0.50 },
        { id: 2, name: "L3+ ASIC Miner", baseUsd: 60, baseYield: 3.20 },
        { id: 3, name: "Mini DOGE Farm", baseUsd: 1800, baseYield: 68.00 },
        { id: 4, name: "Scrypt Mining Pool", baseUsd: 4500, baseYield: 385.00 },
        { id: 5, name: "Industrial DOGE Facility", baseUsd: 18000, baseYield: 2050.00 },
        { id: 6, name: "DOGE Megafarm", baseUsd: 72000, baseYield: 14500.00 },
        { id: 7, name: "WOW Mining Complex", baseUsd: 450000, baseYield: 205000.00 },
        { id: 8, name: "Moon Mining Station", baseUsd: 3400000, baseYield: 2820000.00 },
        { id: 9, name: "Interplanetary DOGE Network", baseUsd: 23000000, baseYield: 26400000.00 },
        { id: 10, name: "To The Moon Supercomputer", baseUsd: 320000000, baseYield: 570000000.00 }
    ].map(u => ({ ...u, level: 0, currentUsd: u.baseUsd, currentYield: 0, boostCost: u.baseUsd * 0.5, boostLevel: 0 }));

    // Keep reference to btcUpgrades as upgrades for backward compatibility
    const upgrades = btcUpgrades;

    // --- SAVE SYSTEM START ---
    function saveGame() {
        const gameState = {
            // Bitcoin data
            btcBalance,
            btcLifetime,
            btcClickValue,
            btcPerSec,
            btcPrice,
            // Ethereum data
            ethBalance,
            ethLifetime,
            ethClickValue,
            ethPerSec,
            ethPrice,
            // Dogecoin data
            dogeBalance,
            dogeLifetime,
            dogeClickValue,
            dogePerSec,
            dogePrice,
            // General data
            dollarBalance,
            hardwareEquity,
            lastSaveTime: Date.now(),
            autoClickerCooldownEnd,
            lifetimeEarnings,
            chartHistory: chartHistory,
            chartTimestamps: chartTimestamps,
            chartStartTime: chartStartTime,
            totalPowerAvailable,
            powerUpgrades: powerUpgrades.map(u => ({
                id: u.id,
                level: u.level,
                currentUsd: u.currentUsd,
                currentPower: u.currentPower
            })),
            btcUpgrades: btcUpgrades.map(u => ({
                id: u.id,
                level: u.level,
                currentUsd: u.currentUsd,
                currentYield: u.currentYield,
                boostCost: u.boostCost,
                boostLevel: u.boostLevel
            })),
            ethUpgrades: ethUpgrades.map(u => ({
                id: u.id,
                level: u.level,
                currentUsd: u.currentUsd,
                currentYield: u.currentYield,
                boostCost: u.boostCost,
                boostLevel: u.boostLevel
            })),
            dogeUpgrades: dogeUpgrades.map(u => ({
                id: u.id,
                level: u.level,
                currentUsd: u.currentUsd,
                currentYield: u.currentYield,
                boostCost: u.boostCost,
                boostLevel: u.boostLevel
            }))
        };
        localStorage.setItem('satoshiTerminalSave', JSON.stringify(gameState));
    }

function loadGame() {
    const savedData = localStorage.getItem('satoshiTerminalSave');
    if (savedData) {
        const state = JSON.parse(savedData);

        // Load Bitcoin data
        btcBalance = state.btcBalance || 0;
        btcLifetime = state.btcLifetime || 0;
        btcClickValue = state.btcClickValue || 0.00000250;
        btcPrice = state.btcPrice || 100000;

        // Load Ethereum data
        ethBalance = state.ethBalance || 0;
        ethLifetime = state.ethLifetime || 0;
        ethClickValue = state.ethClickValue || 0.00007143;
        ethPrice = state.ethPrice || 3500;

        // Load Dogecoin data
        dogeBalance = state.dogeBalance || 0;
        dogeLifetime = state.dogeLifetime || 0;
        dogeClickValue = state.dogeClickValue || 1.00000000;
        dogePrice = state.dogePrice || 0.25;

        // Load general data
        dollarBalance = state.dollarBalance || 0;
        hardwareEquity = state.hardwareEquity || 0;
        lifetimeEarnings = state.lifetimeEarnings || 0;
        previousPortfolioValue = 0; // Reset tracking on load

        // Initialize session tracking
        sessionStartBalance = btcBalance;
        sessionStartNetWorth = (btcBalance * btcPrice) + (ethBalance * ethPrice) + (dogeBalance * dogePrice) + hardwareEquity + dollarBalance;
        chartStartTime = state.chartStartTime || Date.now();

        // Load power upgrades
        if (state.powerUpgrades) {
            state.powerUpgrades.forEach((savedU) => {
                const powerUpgradeToUpdate = powerUpgrades.find(u => u.id === savedU.id);
                if (powerUpgradeToUpdate) {
                    powerUpgradeToUpdate.level = savedU.level || 0;
                    powerUpgradeToUpdate.currentUsd = savedU.currentUsd || powerUpgradeToUpdate.baseUsd;
                    powerUpgradeToUpdate.currentPower = savedU.currentPower || 0;
                }
            });
        }
        totalPowerAvailable = state.totalPowerAvailable || 0;

        // Load BTC upgrades
        if (state.btcUpgrades) {
            state.btcUpgrades.forEach((savedU) => {
                const upgradeToUpdate = btcUpgrades.find(u => u.id === savedU.id);
                if (upgradeToUpdate) {
                    upgradeToUpdate.level = savedU.level || 0;
                    upgradeToUpdate.currentUsd = savedU.currentUsd || upgradeToUpdate.baseUsd;
                    upgradeToUpdate.currentYield = savedU.currentYield || 0;
                    upgradeToUpdate.boostCost = savedU.boostCost || upgradeToUpdate.baseUsd * 0.5;
                    upgradeToUpdate.boostLevel = savedU.boostLevel || 0;
                }
            });
        } else if (state.upgrades) {
            // Backward compatibility: load old saves
            state.upgrades.forEach((savedU, index) => {
                let upgradeToUpdate;
                if (savedU.id !== undefined) {
                    upgradeToUpdate = btcUpgrades.find(u => u.id === savedU.id);
                } else {
                    upgradeToUpdate = btcUpgrades[index];
                }
                if (upgradeToUpdate) {
                    upgradeToUpdate.level = savedU.level || 0;
                    upgradeToUpdate.currentUsd = savedU.currentUsd || upgradeToUpdate.baseUsd;
                    upgradeToUpdate.currentYield = savedU.currentYield || 0;
                    upgradeToUpdate.boostCost = savedU.boostCost || upgradeToUpdate.baseUsd * 0.5;
                    upgradeToUpdate.boostLevel = savedU.boostLevel || 0;
                }
            });
        }

        // Load ETH upgrades
        if (state.ethUpgrades) {
            state.ethUpgrades.forEach((savedU) => {
                const upgradeToUpdate = ethUpgrades.find(u => u.id === savedU.id);
                if (upgradeToUpdate) {
                    upgradeToUpdate.level = savedU.level || 0;
                    upgradeToUpdate.currentUsd = savedU.currentUsd || upgradeToUpdate.baseUsd;
                    upgradeToUpdate.currentYield = savedU.currentYield || 0;
                    upgradeToUpdate.boostCost = savedU.boostCost || upgradeToUpdate.baseUsd * 0.5;
                    upgradeToUpdate.boostLevel = savedU.boostLevel || 0;
                }
            });
        }

        // Load DOGE upgrades
        if (state.dogeUpgrades) {
            state.dogeUpgrades.forEach((savedU) => {
                const upgradeToUpdate = dogeUpgrades.find(u => u.id === savedU.id);
                if (upgradeToUpdate) {
                    upgradeToUpdate.level = savedU.level || 0;
                    upgradeToUpdate.currentUsd = savedU.currentUsd || upgradeToUpdate.baseUsd;
                    upgradeToUpdate.currentYield = savedU.currentYield || 0;
                    upgradeToUpdate.boostCost = savedU.boostCost || upgradeToUpdate.baseUsd * 0.5;
                    upgradeToUpdate.boostLevel = savedU.boostLevel || 0;
                }
            });
        }

        // Calculate total power used
        calculateTotalPowerUsed();

        // Recalculate totals for all cryptos
        btcPerSec = btcUpgrades.reduce((sum, item) => sum + (item.currentYield || 0), 0);
        ethPerSec = ethUpgrades.reduce((sum, item) => sum + (item.currentYield || 0), 0);
        dogePerSec = dogeUpgrades.reduce((sum, item) => sum + (item.currentYield || 0), 0);

        // Restore autoclicker cooldown
        autoClickerCooldownEnd = state.autoClickerCooldownEnd || 0;

        // Calculate offline earnings (max 6 hours of earnings to prevent exploits)
        const lastSaveTime = state.lastSaveTime || Date.now();
        const currentTime = Date.now();
        let offlineSeconds = (currentTime - lastSaveTime) / 1000;
        const maxOfflineSeconds = 21600; // Cap at 6 hours
        if (offlineSeconds > maxOfflineSeconds) offlineSeconds = maxOfflineSeconds;

        const offlineBtcEarnings = btcPerSec * offlineSeconds;
        const offlineEthEarnings = ethPerSec * offlineSeconds;
        const offlineDogeEarnings = dogePerSec * offlineSeconds;

        if (offlineBtcEarnings > 0) {
            btcBalance += offlineBtcEarnings;
            btcLifetime += offlineBtcEarnings;
        }
        if (offlineEthEarnings > 0) {
            ethBalance += offlineEthEarnings;
            ethLifetime += offlineEthEarnings;
        }
        if (offlineDogeEarnings > 0) {
            dogeBalance += offlineDogeEarnings;
            dogeLifetime += offlineDogeEarnings;
        }

        if (offlineBtcEarnings > 0 || offlineEthEarnings > 0 || offlineDogeEarnings > 0) {
            window.offlineEarningsToShow = {
                btc: offlineBtcEarnings,
                eth: offlineEthEarnings,
                doge: offlineDogeEarnings,
                seconds: offlineSeconds
            };
        }

        updateUI();

        // Always reset chart history to start fresh on load
        chartHistory = [];
        chartTimestamps = [];

        // Debug log
        console.log('Loaded save:', { btcBalance, ethBalance, dogeBalance, hardwareEquity });
        console.log('Chart data restored:', chartHistory.length, 'data points');
    }
}
    // --- SAVE SYSTEM END ---

    function calculateTotalPowerUsed() {
        totalPowerUsed = 0;
        // Calculate BTC equipment power
        upgrades.forEach(u => {
            if (u.level > 0 && equipmentPowerReqs[u.id] !== undefined) {
                totalPowerUsed += equipmentPowerReqs[u.id] * u.level;
            }
        });
        // Calculate ETH equipment power
        ethUpgrades.forEach(u => {
            if (u.level > 0 && equipmentPowerReqs[u.id] !== undefined) {
                totalPowerUsed += equipmentPowerReqs[u.id] * u.level;
            }
        });
        // Calculate DOGE equipment power
        dogeUpgrades.forEach(u => {
            if (u.level > 0 && equipmentPowerReqs[u.id] !== undefined) {
                totalPowerUsed += equipmentPowerReqs[u.id] * u.level;
            }
        });
    }

    function resetGame() {
        if (confirm('Are you sure you want to reset your entire save? This cannot be undone!')) {
            localStorage.removeItem('satoshiTerminalSave');
            // Reset all variables to defaults
            btcBalance = 0;
            btcLifetime = 0;
            btcPerSec = 0;
            btcClickValue = 0.00000250;
            ethBalance = 0;
            ethLifetime = 0;
            ethPerSec = 0;
            ethClickValue = 0.00007143;
            dogeBalance = 0;
            dogeLifetime = 0;
            dogePerSec = 0;
            dogeClickValue = 1.00000000;
            dollarBalance = 0;
            hardwareEquity = 0;
            autoClickerCooldownEnd = 0;
            // Reset session stats
            sessionStartTime = Date.now();
            sessionStartBalance = 0;
            sessionStartNetWorth = 0;
            sessionEarnings = 0;
            lifetimeEarnings = 0;
            // Reset chart history
            chartHistory = [];
            chartTimestamps = [];
            chartStartTime = Date.now();
            // Reset power system
            totalPowerAvailable = 0;
            totalPowerUsed = 0;
            powerUpgrades.forEach(u => {
                u.level = 0;
                u.currentUsd = u.baseUsd;
                u.currentPower = 0;
            });
            // Reset all upgrades
            btcUpgrades.forEach(u => {
                u.level = 0;
                u.currentUsd = u.baseUsd;
                u.currentYield = 0;
                u.boostCost = u.baseCost || u.currentUsd;
                u.boostLevel = 0;
            });
            ethUpgrades.forEach(u => {
                u.level = 0;
                u.currentUsd = u.baseUsd;
                u.currentYield = 0;
                u.boostCost = u.baseCost || u.currentUsd;
                u.boostLevel = 0;
            });
            dogeUpgrades.forEach(u => {
                u.level = 0;
                u.currentUsd = u.baseUsd;
                u.currentYield = 0;
                u.boostCost = u.baseCost || u.currentUsd;
                u.boostLevel = 0;
            });
            saveGame();
            updateUI();
            alert('Game reset! Starting fresh.');
        }
    }

    function showOfflineEarningsModal(btcEarned, ethEarned, dogeEarned, secondsOffline) {
        console.log('showOfflineEarningsModal called with:', btcEarned, ethEarned, dogeEarned, secondsOffline);

        const overlay = document.createElement('div');
        overlay.className = 'offline-modal-overlay';

        const modal = document.createElement('div');
        modal.className = 'offline-modal';

        const hours = Math.floor(secondsOffline / 3600);
        const minutes = Math.floor((secondsOffline % 3600) / 60);
        const seconds = Math.floor(secondsOffline % 60);

        let timeStr = '';
        if (hours > 0) timeStr += hours + 'h ';
        if (minutes > 0) timeStr += minutes + 'm ';
        if (seconds > 0) timeStr += seconds + 's';
        if (!timeStr) timeStr = '< 1s';

        let earningsHtml = '';
        if (btcEarned > 0) {
            earningsHtml += `<div class="earnings" style="color: #f7931a;">₿ ${btcEarned.toFixed(8)}</div>`;
        }
        if (ethEarned > 0) {
            earningsHtml += `<div class="earnings" style="color: #627eea;">Ξ ${ethEarned.toFixed(8)}</div>`;
        }
        if (dogeEarned > 0) {
            earningsHtml += `<div class="earnings" style="color: #c2a633;">Ð ${dogeEarned.toFixed(2)}</div>`;
        }

        modal.innerHTML = `
            <h2>⏰ Welcome Back!</h2>
            <div class="earnings-label">Offline Earnings</div>
            ${earningsHtml}
            <div class="time-offline">While you were away for ${timeStr}</div>
            <button id="claim-btn">Claim Rewards</button>
        `;

        document.body.appendChild(overlay);
        document.body.appendChild(modal);

        document.getElementById('claim-btn').onclick = () => {
            overlay.remove();
            modal.remove();
        };

        console.log('Modal created and appended');
    }

    // Sound mute toggle
    let isMuted = false;
    function toggleMute() {
        isMuted = !isMuted;
        const btn = document.getElementById('mute-btn');
        if (btn) {
            btn.innerText = isMuted ? 'SOUND OFF' : 'SOUND ON';
        }
    }

    // Auto-clicker state
    let autoClickerActive = false;
    let autoClickerCooldownEnd = 0;
    const AUTO_CLICKER_DURATION = 30000; // 30 seconds
    const AUTO_CLICKER_COOLDOWN = 300000; // 5 minutes

    function startAutoClicker() {
        if (autoClickerCooldownEnd > Date.now()) {
            return; // Still on cooldown
        }

        autoClickerActive = true;
        autoClickerCooldownEnd = Date.now() + AUTO_CLICKER_COOLDOWN;
        let clicksRemaining = AUTO_CLICKER_DURATION / 200; // 5 clicks/sec = 1 click every 200ms

        const clickInterval = setInterval(() => {
            if (clicksRemaining > 0) {
                // Click all three crypto types
                manualHash();      // BTC
                manualEthHash();   // ETH
                manualDogeHash();  // DOGE
                clicksRemaining--;
            } else {
                clearInterval(clickInterval);
                autoClickerActive = false;
                updateAutoClickerButtonState();
            }
        }, 200);

        updateAutoClickerButtonState();
    }

    function updateAutoClickerButtonState() {
        const btn = document.getElementById('autoclicker-btn');
        if (!btn) return;

        const now = Date.now();
        if (autoClickerCooldownEnd > now) {
            const cooldownMs = autoClickerCooldownEnd - now;
            const seconds = Math.ceil(cooldownMs / 1000);
            btn.disabled = true;
            btn.innerText = `AUTO CLICKER • COOLDOWN: ${seconds}s`;
        } else {
            btn.disabled = false;
            btn.innerText = 'AUTO CLICKER • 5 clicks/sec • 30s • 5m cooldown';
        }
    }

    function initBtcShop() {
        const container = document.getElementById('btc-shop');
        container.innerHTML = '';

        btcUpgrades.forEach((u, i) => {
            const btn = document.createElement('button');
            btn.className = 'u-item';
            btn.id = `up-${u.id}`;
        // All upgrades use the same purchase function
        btn.onclick = () => buyLevelMultiple(i, buyQuantity);

        const powerReq = equipmentPowerReqs[u.id] || 0;
        const powerDisplay = powerReq > 0 ? `<span style="font-size:0.9rem;color:var(--btc);font-weight:700;display:block;margin-top:3px">${powerReq.toLocaleString()}W Consumed per level</span>` : '';

        btn.innerHTML = `
            <div style="text-align:left;flex:1">
                <div style="font-size:0.9rem;color:#f7931a;font-weight:700;text-transform:uppercase;letter-spacing:1px;display:block;margin-bottom:2px"><span id="lvl-txt-${u.id}">[Lvl 0]</span> ${u.name}</div>
                <div style="font-size:1.1rem;color:var(--green);font-family:monospace;font-weight:700;display:block;margin-bottom:3px" id="yield-${u.id}">+0 ₿/s - Current Speed</div>
                <div style="font-size:0.9rem;color:#f7931a;font-weight:700;display:block;margin-top:3px" id="increase-${u.id}">+0 ₿/s per level</div>
                ${powerDisplay}
            </div>
            <div style="text-align:right;display:flex;flex-direction:column;align-items:flex-end">
                <span style="font-size:1.3rem;font-weight:900;display:block;color:#fff" id="usd-${u.id}">$${u.baseUsd.toLocaleString()}</span>
                <span style="font-size:0.75rem;color:#00ff88;font-family:monospace;font-weight:900;margin-top:2px" id="afford-${u.id}">x0</span>
            </div>`;
        container.appendChild(btn);

        // Add boost button only for non-manual upgrades
        if (!u.isClickUpgrade) {
            const boostBtn = document.createElement('button');
            boostBtn.id = `boost-${u.id}`;
            boostBtn.style.background = '#ff9500';
            boostBtn.style.border = 'none';
            boostBtn.style.borderRadius = '6px';
            boostBtn.style.padding = '6px 10px';
            boostBtn.style.fontSize = '0.7rem';
            boostBtn.style.fontWeight = '700';
            boostBtn.style.color = '#000';
            boostBtn.style.cursor = 'pointer';
            boostBtn.style.marginTop = '2px';
            boostBtn.style.width = '100%';
            boostBtn.style.transition = '0.1s';
            boostBtn.onclick = () => buyBoost(i);
            boostBtn.innerHTML = `+10% HASH RATE | <span id="boost-cost-${u.id}">$0</span>`;
            boostBtn.disabled = u.level === 0;
            boostBtn.setAttribute('data-upgrade-name', u.name);
            container.appendChild(boostBtn);
        }
        });
    }

    function initPowerShop() {
        const container = document.getElementById('power-shop');
        container.innerHTML = '';

        powerUpgrades.forEach((u, i) => {
            const btn = document.createElement('button');
            btn.className = 'u-item';
            btn.id = `pow-${u.id}`;
            btn.onclick = () => buyPowerUpgrade(i);

            const costBtc = u.currentUsd / btcPrice;
            btn.innerHTML = `
                <div style="text-align:left;flex:1">
                    <div style="font-size:0.9rem;color:#00ff88;font-weight:700;text-transform:uppercase;letter-spacing:1px;display:block;margin-bottom:2px"><span id="pow-lvl-txt-${u.id}">[Lvl ${u.level}]</span> ${u.name}</div>
                    <div style="font-size:1.1rem;color:var(--green);font-family:monospace;font-weight:700;display:block;margin-bottom:3px" id="pow-current-${u.id}">+0W - Current Power</div>
                    <div style="font-size:1.1rem;color:#00ff88;font-family:monospace;font-weight:700;display:block" id="pow-power-${u.id}">+0W Produced per level</div>
                </div>
                <div style="text-align:right;display:flex;flex-direction:column;align-items:flex-end">
                    <span style="font-size:1.3rem;font-weight:900;display:block;color:#fff" id="pow-usd-${u.id}">$${u.currentUsd.toLocaleString()}</span>
                    <span style="font-size:0.75rem;color:#00ff88;font-family:monospace;font-weight:900;margin-top:2px" id="pow-afford-${u.id}">x0</span>
                </div>`;
            container.appendChild(btn);
        });
    }

    function initEthShop() {
        const container = document.getElementById('eth-shop');
        container.innerHTML = '';

        ethUpgrades.forEach((u, i) => {
            const btn = document.createElement('button');
            btn.className = 'u-item';
            btn.id = `eth-up-${u.id}`;
            if (u.isClickUpgrade) {
                btn.classList.add('click-upgrade');
            }

            btn.onclick = () => buyEthLevel(i, buyQuantity);

            const powerReq = equipmentPowerReqs[u.id] || 0;
            const powerDisplay = powerReq > 0 ? `<span style="font-size:0.9rem;color:#627eea;font-weight:700;display:block;margin-top:3px">${powerReq.toLocaleString()}W Consumed per level</span>` : '';

            btn.innerHTML = `
                <div style="text-align:left;flex:1">
                    <div style="font-size:0.9rem;color:#627eea;font-weight:700;text-transform:uppercase;letter-spacing:1px;display:block;margin-bottom:2px"><span id="eth-lvl-txt-${u.id}">[Lvl 0]</span> ${u.name}</div>
                    <div style="font-size:1.1rem;color:var(--green);font-family:monospace;font-weight:700;display:block;margin-bottom:3px" id="eth-yield-${u.id}">+0 Ξ/s - Current Speed</div>
                    <div style="font-size:0.9rem;color:#627eea;font-weight:700;display:block;margin-top:3px" id="eth-increase-${u.id}">+0 Ξ/s per level</div>
                    ${powerDisplay}
                </div>
                <div style="text-align:right;display:flex;flex-direction:column;align-items:flex-end">
                    <span style="font-size:1.3rem;font-weight:900;display:block;color:#fff" id="eth-usd-${u.id}">$${u.baseUsd.toLocaleString()}</span>
                    <span style="font-size:0.75rem;color:#00ff88;font-family:monospace;font-weight:900;margin-top:2px" id="eth-afford-${u.id}">x0</span>
                </div>`;
            container.appendChild(btn);

            // Add boost button only for non-manual upgrades
            if (!u.isClickUpgrade) {
                const boostBtn = document.createElement('button');
                boostBtn.id = `eth-boost-${u.id}`;
                boostBtn.style.background = '#ff9500';
                boostBtn.style.border = 'none';
                boostBtn.style.borderRadius = '6px';
                boostBtn.style.padding = '6px 10px';
                boostBtn.style.fontSize = '0.7rem';
                boostBtn.style.fontWeight = '700';
                boostBtn.style.color = '#000';
                boostBtn.style.cursor = 'pointer';
                boostBtn.style.marginTop = '2px';
                boostBtn.style.width = '100%';
                boostBtn.style.transition = '0.1s';
                boostBtn.onclick = () => buyEthBoost(i);
                boostBtn.innerHTML = `+10% HASH RATE | <span id="eth-boost-cost-${u.id}">$0</span>`;
                boostBtn.disabled = u.level === 0;
                boostBtn.setAttribute('data-upgrade-name', u.name);
                container.appendChild(boostBtn);
            }
        });
    }

    function initDogeShop() {
        const container = document.getElementById('doge-shop');
        container.innerHTML = '';

        dogeUpgrades.forEach((u, i) => {
            const btn = document.createElement('button');
            btn.className = 'u-item';
            btn.id = `doge-up-${u.id}`;
            if (u.isClickUpgrade) {
                btn.classList.add('click-upgrade');
            }

            btn.onclick = () => buyDogeLevel(i, buyQuantity);

            const powerReq = equipmentPowerReqs[u.id] || 0;
            const powerDisplay = powerReq > 0 ? `<span style="font-size:0.9rem;color:#c2a633;font-weight:700;display:block;margin-top:3px">${powerReq.toLocaleString()}W Consumed per level</span>` : '';

            btn.innerHTML = `
                <div style="text-align:left;flex:1">
                    <div style="font-size:0.9rem;color:#c2a633;font-weight:700;text-transform:uppercase;letter-spacing:1px;display:block;margin-bottom:2px"><span id="doge-lvl-txt-${u.id}">[Lvl 0]</span> ${u.name}</div>
                    <div style="font-size:1.1rem;color:var(--green);font-family:monospace;font-weight:700;display:block;margin-bottom:3px" id="doge-yield-${u.id}">+0 Ð/s - Current Speed</div>
                    <div style="font-size:0.9rem;color:#c2a633;font-weight:700;display:block;margin-top:3px" id="doge-increase-${u.id}">+0 Ð/s per level</div>
                    ${powerDisplay}
                </div>
                <div style="text-align:right;display:flex;flex-direction:column;align-items:flex-end">
                    <span style="font-size:1.3rem;font-weight:900;display:block;color:#fff" id="doge-usd-${u.id}">$${u.baseUsd.toLocaleString()}</span>
                    <span style="font-size:0.75rem;color:#00ff88;font-family:monospace;font-weight:900;margin-top:2px" id="doge-afford-${u.id}">x0</span>
                </div>`;
            container.appendChild(btn);

            // Add boost button only for non-manual upgrades
            if (!u.isClickUpgrade) {
                const boostBtn = document.createElement('button');
                boostBtn.id = `doge-boost-${u.id}`;
                boostBtn.style.background = '#ff9500';
                boostBtn.style.border = 'none';
                boostBtn.style.borderRadius = '6px';
                boostBtn.style.padding = '6px 10px';
                boostBtn.style.fontSize = '0.7rem';
                boostBtn.style.fontWeight = '700';
                boostBtn.style.color = '#000';
                boostBtn.style.cursor = 'pointer';
                boostBtn.style.marginTop = '2px';
                boostBtn.style.width = '100%';
                boostBtn.style.transition = '0.1s';
                boostBtn.onclick = () => buyDogeBoost(i);
                boostBtn.innerHTML = `+10% HASH RATE | <span id="doge-boost-cost-${u.id}">$0</span>`;
                boostBtn.disabled = u.level === 0;
                boostBtn.setAttribute('data-upgrade-name', u.name);
                container.appendChild(boostBtn);
            }
        });
    }

    function switchTab(tab) {
        document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));

        document.getElementById(tab + '-tab').classList.add('active');
        event.target.classList.add('active');

        // Reset purchase quantity to 1x when switching tabs
        setBuyQuantity(1);
    }

    function setBuyQuantity(qty) {
        buyQuantity = qty;
        // All buttons are grey
        const defaultColor = '#888';

        document.querySelectorAll('.qty-toggle').forEach(el => {
            el.classList.remove('active');
            // Reset to default grey color
            el.style.borderColor = defaultColor;
            el.style.color = defaultColor;
        });

        // Find and highlight the active button in the current tab
        document.querySelectorAll('.qty-toggle').forEach(el => {
            if (el.textContent.trim() === `${qty}x`) {
                el.classList.add('active');
                el.style.borderColor = '#666';
                el.style.color = '#fff';
                el.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.2)';
            }
        });
    }

    // Market sell functions
    function sellBTC(amount) {
        if (btcBalance < amount) {
            alert('Not enough Bitcoin!');
            return;
        }
        btcBalance -= amount;
        dollarBalance += amount * btcPrice;
        updateUI();
        saveGame();
        playUpgradeSound();
    }

    function sellAllBTC() {
        if (btcBalance <= 0) return;
        const saleValue = btcBalance * btcPrice * 0.95; // 5% fee
        dollarBalance += saleValue;
        btcBalance = 0;
        updateUI();
        saveGame();
        playUpgradeSound();
    }

    function sellETH(amount) {
        if (ethBalance < amount) {
            alert('Not enough Ethereum!');
            return;
        }
        ethBalance -= amount;
        const saleValue = amount * ethPrice * 0.95; // 5% fee
        dollarBalance += saleValue;
        updateUI();
        saveGame();
        playUpgradeSound();
    }

    function sellAllETH() {
        if (ethBalance <= 0) return;
        const saleValue = ethBalance * ethPrice * 0.95; // 5% fee
        dollarBalance += saleValue;
        ethBalance = 0;
        updateUI();
        saveGame();
        playUpgradeSound();
    }

    function sellDOGE(amount) {
        // DOGE uses whole numbers
        if (dogeBalance < amount) {
            alert('Not enough Dogecoin!');
            return;
        }
        dogeBalance -= amount;
        const saleValue = amount * dogePrice * 0.95; // 5% fee
        dollarBalance += saleValue;
        updateUI();
        saveGame();
        playUpgradeSound();
    }

    function sellAllDOGE() {
        if (dogeBalance <= 0) return;
        dollarBalance += dogeBalance * dogePrice;
        dogeBalance = 0;
        updateUI();
        saveGame();
        playUpgradeSound();
    }

    function buyPowerUpgrade(i) {
        const u = powerUpgrades[i];
        const costUsd = u.currentUsd;

        if (dollarBalance >= costUsd) {
            dollarBalance -= costUsd;
            hardwareEquity += u.currentUsd;
            u.level++;
            u.currentPower = u.basePower * u.level;
            totalPowerAvailable += u.basePower;

            // Update price with 1.2x multiplier
            u.currentUsd = Math.floor(u.baseUsd * Math.pow(1.2, u.level));

            updateUI();
            saveGame();
            playUpgradeSound();
        }
    }

    function updatePowerDisplay() {
        const powerUsedEl = document.getElementById('power-used');
        if (powerUsedEl) {
            powerUsedEl.innerText = totalPowerUsed.toLocaleString() + 'W / ' + totalPowerAvailable.toLocaleString() + 'W';

            // Dynamic color for power text based on usage
            const percentage = totalPowerAvailable > 0 ? (totalPowerUsed / totalPowerAvailable * 100) : 0;
            if (percentage > 100) {
                powerUsedEl.style.color = '#ff3344'; // Red - over capacity
            } else if (percentage > 80) {
                powerUsedEl.style.color = '#ff9500'; // Orange - critical
            } else if (percentage > 60) {
                powerUsedEl.style.color = '#ffdd00'; // Yellow - warning
            } else {
                powerUsedEl.style.color = '#00ff88'; // Green - safe
            }
        }

        const powerBarFill = document.getElementById('power-bar-fill');
        if (powerBarFill) {
            const percentage = totalPowerAvailable > 0 ? (totalPowerUsed / totalPowerAvailable * 100) : 0;
            powerBarFill.style.width = Math.min(percentage, 100) + '%';

            // Dynamic color for power bar based on usage
            if (percentage > 100) {
                powerBarFill.style.background = '#ff3344'; // Red - over capacity
            } else if (percentage > 80) {
                powerBarFill.style.background = '#ff9500'; // Orange - critical
            } else if (percentage > 60) {
                powerBarFill.style.background = '#ffdd00'; // Yellow - warning
            } else {
                powerBarFill.style.background = '#00ff88'; // Green - safe
            }
        }

        // Update power upgrades display
        powerUpgrades.forEach(u => {
            const costUsd = u.currentUsd;
            const lvlEl = document.getElementById(`pow-lvl-txt-${u.id}`);
            if (lvlEl) lvlEl.innerText = `[Lvl ${u.level}]`;

            const currentPowerEl = document.getElementById(`pow-current-${u.id}`);
            if (currentPowerEl) currentPowerEl.innerText = `+${u.currentPower.toLocaleString()}W - Current Power`;

            const powerEl = document.getElementById(`pow-power-${u.id}`);
            if (powerEl) powerEl.innerText = `+${u.basePower.toLocaleString()}W Produced per level`;

            const usdEl = document.getElementById(`pow-usd-${u.id}`);
            if (usdEl) usdEl.innerText = `$${u.currentUsd.toLocaleString()}`;

            // Calculate how many power upgrades can be afforded (accounting for price increases)
            const affordEl = document.getElementById(`pow-afford-${u.id}`);
            if (affordEl) {
                let remaining = dollarBalance;
                let canAfford = 0;
                let nextCost = costUsd;
                let nextLevel = u.level;

                while (remaining >= nextCost) {
                    remaining -= nextCost;
                    canAfford++;
                    nextLevel++;
                    // Power upgrades: 1.2x multiplier
                    nextCost = u.baseUsd * Math.pow(1.2, nextLevel);
                }

                affordEl.innerText = `x${canAfford}`;
                affordEl.style.color = canAfford > 0 ? '#00ff88' : '#666';
            }

            const btn = document.getElementById(`pow-${u.id}`);
            if (btn) btn.disabled = (dollarBalance < costUsd);
        });
    }

function manualHash() {
    // This adds your current click power to your spendable balance
    btcBalance += btcClickValue;

    // This ensures every manual click also increases your Lifetime Total
    btcLifetime += btcClickValue;

    // Track clicks for hashrate
    const now = Date.now();
    manualHashClickTime = now;
    manualHashCooldownEnd = now + 1000;
    clickTimestamps.push(now);
    if (clickTimestamps.length > 60) clickTimestamps.shift();

    // Play click sound
    playClickSound();

    // This refreshes the screen so you see the numbers go up
    updateUI();
}

function manualEthHash() {
    // Add ETH to balance
    ethBalance += ethClickValue;
    ethLifetime += ethClickValue;

    // Track clicks for hashrate
    const now = Date.now();
    manualHashClickTime = now;
    manualHashCooldownEnd = now + 1000;
    clickTimestamps.push(now);
    if (clickTimestamps.length > 60) clickTimestamps.shift();

    // Play click sound
    playClickSound();

    // Refresh the screen
    updateUI();
}

function manualDogeHash() {
    // Add DOGE to balance
    dogeBalance += dogeClickValue;
    dogeLifetime += dogeClickValue;

    // Track clicks for hashrate
    const now = Date.now();
    manualHashClickTime = now;
    manualHashCooldownEnd = now + 1000;
    clickTimestamps.push(now);
    if (clickTimestamps.length > 60) clickTimestamps.shift();

    // Play click sound
    playClickSound();

    // Refresh the screen
    updateUI();
}

function buyLevel(i) {
    const u = upgrades[i];
    const costBtc = u.currentUsd / btcPrice;

    if (btcBalance >= costBtc) {
        // Check power requirements
        const powerReq = equipmentPowerReqs[u.id] || 0;
        const powerNeeded = totalPowerUsed + (powerReq * (u.level + 1));

        if (powerNeeded > totalPowerAvailable && powerReq > 0) {
            alert(`Insufficient power! This upgrade requires ${powerReq.toLocaleString()}W per level.\nYou need ${Math.ceil(powerNeeded - totalPowerAvailable).toLocaleString()}W more power capacity.`);
            return;
        }

        btcBalance -= costBtc;
        hardwareEquity += u.currentUsd;
        u.level++;

        // Check if this is the Manual Hash upgrade
        if (u.id === 0 || u.isClickUpgrade) {
            // Increase click value by 10%
            btcClickValue *= 1.10;

            // FASTER PRICE SCALE: % increase per level
            u.currentUsd = Math.floor(u.baseUsd * Math.pow(1.75, u.level));

            // Update the main orange button text to show new click value
            document.querySelector('.mine-btn span').innerText = `+${btcClickValue.toFixed(8)} ₿`;
        } else {
            // ALL OTHER MINERS: Standard 15% increase
            u.currentYield = u.baseYield * u.level * Math.pow(1.10, u.boostLevel);
            u.currentUsd = Math.floor(u.baseUsd * Math.pow(1.15, u.level));
        }

        btcPerSec = upgrades.reduce((sum, item) => sum + (item.currentYield || 0), 0);
        updateUI();
        saveGame();

        // Play upgrade sound
        playUpgradeSound();
    }
}

function buyLevelMultiple(i, quantity) {
    const u = upgrades[i];
    const powerReq = equipmentPowerReqs[u.id] || 0;
    let purchased = 0;

    for (let q = 0; q < quantity; q++) {
        const costUsd = u.currentUsd;

        if (dollarBalance < costUsd) {
            break; // Not enough dollars
        }

        // Check power requirements
        if (powerReq > 0) {
            const powerNeeded = totalPowerUsed + (powerReq * (u.level + 1));
            if (powerNeeded > totalPowerAvailable) {
                break; // Not enough power
            }
        }

        dollarBalance -= costUsd;
        hardwareEquity += u.currentUsd;
        u.level++;

        // Update price and yield based on upgrade type
        if (u.id === 0 || u.isClickUpgrade) {
            btcClickValue *= 1.10;
            u.currentUsd = Math.floor(u.baseUsd * Math.pow(1.75, u.level));
        } else {
            u.currentYield = u.baseYield * u.level * Math.pow(1.10, u.boostLevel);
            u.currentUsd = Math.floor(u.baseUsd * Math.pow(1.15, u.level));
        }

        purchased++;
        calculateTotalPowerUsed();
    }

    if (purchased > 0) {
        if (u.id === 0 || u.isClickUpgrade) {
            document.querySelector('.mine-btn span').innerText = `+${btcClickValue.toFixed(8)} ₿`;
        }
        btcPerSec = upgrades.reduce((sum, item) => sum + (item.currentYield || 0), 0);
        updateUI();
        saveGame();
        playUpgradeSound();
    }
}

function buyBoost(i) {
    const u = upgrades[i];

    // Check if upgrade level is 0 (not purchased yet)
    if (u.level === 0) {
        return; // Cannot boost if upgrade hasn't been purchased
    }

    const costUsd = u.boostCost;

    if (dollarBalance >= costUsd) {
        dollarBalance -= costUsd;
        hardwareEquity += u.boostCost;
        u.boostLevel++;

        // Increase yield by 10% permanently
        u.currentYield *= 1.10;

        // Double the boost cost for next purchase
        u.boostCost *= 2;

        btcPerSec = upgrades.reduce((sum, item) => sum + (item.currentYield || 0), 0);
        updateUI();
        saveGame();

        // Play upgrade sound
        playUpgradeSound();
    }
}

function buyEthBoost(i) {
    const u = ethUpgrades[i];

    // Check if upgrade level is 0 (not purchased yet)
    if (u.level === 0) {
        return; // Cannot boost if upgrade hasn't been purchased
    }

    const costUsd = u.boostCost;

    if (dollarBalance >= costUsd) {
        dollarBalance -= costUsd;
        hardwareEquity += u.boostCost;
        u.boostLevel++;

        // Increase yield by 10% permanently
        u.currentYield *= 1.10;

        // Double the boost cost for next purchase
        u.boostCost *= 2;

        ethPerSec = ethUpgrades.reduce((sum, item) => sum + (item.currentYield || 0), 0);
        updateUI();
        saveGame();

        // Play upgrade sound
        playUpgradeSound();
    }
}

function buyDogeBoost(i) {
    const u = dogeUpgrades[i];

    // Check if upgrade level is 0 (not purchased yet)
    if (u.level === 0) {
        return; // Cannot boost if upgrade hasn't been purchased
    }

    const costUsd = u.boostCost;

    if (dollarBalance >= costUsd) {
        dollarBalance -= costUsd;
        hardwareEquity += u.boostCost;
        u.boostLevel++;

        // Increase yield by 10% permanently
        u.currentYield *= 1.10;

        // Double the boost cost for next purchase
        u.boostCost *= 2;

        dogePerSec = dogeUpgrades.reduce((sum, item) => sum + (item.currentYield || 0), 0);
        updateUI();
        saveGame();

        // Play upgrade sound
        playUpgradeSound();
    }
}

    // Ethereum buy functions
    function buyEthLevel(i, quantity) {
        const u = ethUpgrades[i];
        const powerReq = equipmentPowerReqs[u.id] || 0;
        let purchased = 0;

        for (let q = 0; q < quantity; q++) {
            const costUsd = u.currentUsd;

            if (dollarBalance < costUsd) {
                break; // Not enough dollars
            }

            // Check power requirements
            if (powerReq > 0) {
                const powerNeeded = totalPowerUsed + (powerReq * (u.level + 1));
                if (powerNeeded > totalPowerAvailable) {
                    break; // Not enough power
                }
            }

            dollarBalance -= costUsd;
            hardwareEquity += u.currentUsd;
            u.level++;

            // Update price and yield based on upgrade type
            if (u.id === 0 || u.isClickUpgrade) {
                ethClickValue *= 1.10;
                u.currentUsd = Math.floor(u.baseUsd * Math.pow(1.75, u.level));
                // Update the ETH button text to show new click value
                document.querySelectorAll('.mine-btn span')[1].innerText = `+${ethClickValue.toFixed(8)} Ξ`;
            } else {
                u.currentYield = u.baseYield * u.level * Math.pow(1.10, u.boostLevel);
                u.currentUsd = Math.floor(u.baseUsd * Math.pow(1.15, u.level));
            }

            purchased++;
            calculateTotalPowerUsed();
        }

        if (purchased > 0) {
            ethPerSec = ethUpgrades.reduce((sum, item) => sum + (item.currentYield || 0), 0);
            updateUI();
            saveGame();
            playUpgradeSound();
        }
    }

    // Dogecoin buy functions
    function buyDogeLevel(i, quantity) {
        const u = dogeUpgrades[i];
        const powerReq = equipmentPowerReqs[u.id] || 0;
        let purchased = 0;

        for (let q = 0; q < quantity; q++) {
            const costUsd = u.currentUsd;

            if (dollarBalance < costUsd) {
                break; // Not enough dollars
            }

            // Check power requirements
            if (powerReq > 0) {
                const powerNeeded = totalPowerUsed + (powerReq * (u.level + 1));
                if (powerNeeded > totalPowerAvailable) {
                    break; // Not enough power
                }
            }

            dollarBalance -= costUsd;
            hardwareEquity += u.currentUsd;
            u.level++;

            // Update price and yield based on upgrade type
            if (u.id === 0 || u.isClickUpgrade) {
                dogeClickValue *= 1.10;
                u.currentUsd = Math.floor(u.baseUsd * Math.pow(1.75, u.level));
                // Update the DOGE button text to show new click value
                document.querySelectorAll('.mine-btn span')[2].innerText = `+${dogeClickValue.toFixed(8)} Ð`;
            } else {
                u.currentYield = u.baseYield * u.level * Math.pow(1.10, u.boostLevel);
                u.currentUsd = Math.floor(u.baseUsd * Math.pow(1.15, u.level));
            }

            purchased++;
            calculateTotalPowerUsed();
        }

        if (purchased > 0) {
            dogePerSec = dogeUpgrades.reduce((sum, item) => sum + (item.currentYield || 0), 0);
            updateUI();
            saveGame();
            playUpgradeSound();
        }
    }

    function updateSessionStats() {
        // Update session time
        const now = Date.now();
        const sessionSeconds = Math.floor((now - sessionStartTime) / 1000);
        const hours = Math.floor(sessionSeconds / 3600);
        const minutes = Math.floor((sessionSeconds % 3600) / 60);
        const seconds = sessionSeconds % 60;

        let timeStr = '';
        if (hours > 0) timeStr += hours + 'h ';
        if (minutes > 0) timeStr += minutes + 'm ';
        timeStr += seconds + 's';

        document.getElementById('session-time').innerText = timeStr;

        // Update lifetime earnings - only increases, never decreases
        const currentPortfolioValue = (btcBalance * btcPrice) + (ethBalance * ethPrice) + (dogeBalance * dogePrice);
        const valueIncrease = currentPortfolioValue - previousPortfolioValue;
        if (valueIncrease > 0) {
            lifetimeEarnings += valueIncrease;
        }
        previousPortfolioValue = currentPortfolioValue;
        document.getElementById('session-earnings').innerText = '$' + lifetimeEarnings.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
    }

    function updateUI() {
        // Crypto portfolio value = value of all crypto holdings only
        let cryptoPortfolioValue = (btcBalance * btcPrice) + (ethBalance * ethPrice) + (dogeBalance * dogePrice);
        document.getElementById('nw-val').innerText = "$" + cryptoPortfolioValue.toLocaleString(undefined, {minimumFractionDigits: 2});

        // Update balances
        document.getElementById('bal-btc').innerText = btcBalance.toFixed(8);
        document.getElementById('bal-eth').innerText = ethBalance.toFixed(8);
        document.getElementById('bal-doge').innerText = dogeBalance.toFixed(8);

        // Update hardware equity
        document.getElementById('asset-usd').innerText = "$" + Math.floor(hardwareEquity).toLocaleString();

        // Update individual hashrate displays (old location - keep for backwards compatibility)
        const btcEl = document.getElementById('yield-btc');
        const ethEl = document.getElementById('yield-eth');
        const dogeEl = document.getElementById('yield-doge');

        if (btcEl) btcEl.innerText = btcPerSec.toFixed(8) + "/s";
        if (ethEl) ethEl.innerText = ethPerSec.toFixed(8) + "/s";
        if (dogeEl) dogeEl.innerText = dogePerSec.toFixed(2) + "/s";

        // Update hashrate displays in new location
        const btcDisplayEl = document.getElementById('yield-btc-display');
        const ethDisplayEl = document.getElementById('yield-eth-display');
        const dogeDisplayEl = document.getElementById('yield-doge-display');

        if (btcDisplayEl) btcDisplayEl.innerText = btcPerSec.toFixed(8) + "/s";
        if (ethDisplayEl) ethDisplayEl.innerText = ethPerSec.toFixed(8) + "/s";
        if (dogeDisplayEl) dogeDisplayEl.innerText = dogePerSec.toFixed(8) + "/s";

        // Update prices
        document.getElementById('btc-price').innerText = "$" + Math.floor(btcPrice).toLocaleString();
        document.getElementById('eth-price').innerText = "$" + Math.floor(ethPrice).toLocaleString();
        document.getElementById('doge-price').innerText = "$" + dogePrice.toFixed(4);

        // Update dollar balance
        const dollarBalanceEl = document.getElementById('dollar-balance');
        if (dollarBalanceEl) dollarBalanceEl.innerText = "$" + Math.floor(dollarBalance).toLocaleString();

        // Update market prices
        const marketBtcPrice = document.getElementById('market-btc-price');
        const marketEthPrice = document.getElementById('market-eth-price');
        const marketDogePrice = document.getElementById('market-doge-price');
        if (marketBtcPrice) marketBtcPrice.innerText = Math.floor(btcPrice).toLocaleString();
        if (marketEthPrice) marketEthPrice.innerText = Math.floor(ethPrice).toLocaleString();
        if (marketDogePrice) marketDogePrice.innerText = dogePrice.toFixed(4);

        // Update session stats
        updateSessionStats();

        // Update power display
        calculateTotalPowerUsed();
        updatePowerDisplay();

        btcUpgrades.forEach(u => {
    const costUsd = u.currentUsd;
    const yEl = document.getElementById(`yield-${u.id}`);

    if (yEl) {
        if (u.isClickUpgrade) {
            yEl.innerText = `+10% MANUAL HASH RATE`;
        } else {
            // Show the current speed
            const currentSpeed = u.baseYield * u.level * Math.pow(1.10, u.boostLevel);
            yEl.innerText = `+${currentSpeed.toFixed(8)} ₿/s - Current Speed`;
        }
    }

    // Update per-level increase
    const increaseEl = document.getElementById(`increase-${u.id}`);
    if (increaseEl) {
        if (u.isClickUpgrade) {
            increaseEl.style.display = 'none';
        } else {
            const perLevelIncrease = u.baseYield * Math.pow(1.10, u.boostLevel);
            increaseEl.innerText = `+${perLevelIncrease.toFixed(8)} ₿/s per level`;
            increaseEl.style.display = 'block';
        }
    }

    const uEl = document.getElementById(`usd-${u.id}`);
    if(uEl) uEl.innerText = `$${u.currentUsd.toLocaleString()}`;

    // Calculate how many upgrades can be afforded (accounting for price increases)
    const affordEl = document.getElementById(`afford-${u.id}`);
    if(affordEl) {
        let remaining = dollarBalance;
        let canAfford = 0;
        let nextCost = costUsd;
        let nextLevel = u.level;

        while (remaining >= nextCost) {
            remaining -= nextCost;
            canAfford++;
            nextLevel++;

            // Calculate next cost based on upgrade type
            if (u.isClickUpgrade) {
                // Manual hash: 1.75x multiplier
                nextCost = u.baseUsd * Math.pow(1.75, nextLevel);
            } else {
                // Other miners: 1.15x multiplier
                nextCost = u.baseUsd * Math.pow(1.15, nextLevel);
            }
        }

        affordEl.innerText = `x${canAfford}`;
        affordEl.style.color = canAfford > 0 ? '#00ff88' : '#666';
    }

    const bEl = document.getElementById(`up-${u.id}`);
    if(bEl) {
        // Check both dollar balance and power requirements
        const hasEnoughDollars = dollarBalance >= costUsd;
        const powerReq = equipmentPowerReqs[u.id] || 0;
        const powerNeeded = totalPowerUsed + (powerReq * (u.level + 1));
        const hasEnoughPower = powerNeeded <= totalPowerAvailable || powerReq === 0;
        const shouldDisable = !(hasEnoughDollars && hasEnoughPower);
        bEl.disabled = shouldDisable;
        if (u.id === 1) console.log(`USB Miner: dollars=${dollarBalance}/${costUsd}, power=${totalPowerUsed}/${totalPowerAvailable}, needed=${powerNeeded}, disabled=${shouldDisable}`);

        // Change button appearance if power is insufficient
        if (!hasEnoughPower && powerReq > 0) {
            // Show overlay message
            let overlay = bEl.querySelector('.power-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'power-overlay';
                overlay.style.position = 'absolute';
                overlay.style.inset = '0';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.style.background = 'rgba(0,0,0,0.8)';
                overlay.style.borderRadius = '10px';
                overlay.style.color = '#999';
                overlay.style.fontWeight = 'bold';
                overlay.style.fontSize = '1.1rem';
                overlay.style.textAlign = 'center';
                overlay.innerHTML = 'YOU NEED MORE POWER';
                bEl.style.position = 'relative';
                bEl.appendChild(overlay);
            }
            bEl.title = `Insufficient power! This requires ${powerReq.toLocaleString()}W per level. Need ${Math.ceil(powerNeeded - totalPowerAvailable).toLocaleString()}W more power capacity.`;
        } else {
            // Hide overlay if it exists
            let overlay = bEl.querySelector('.power-overlay');
            if (overlay) overlay.remove();

            if (!hasEnoughDollars) {
                bEl.title = `Need $${(costUsd - dollarBalance).toLocaleString()} more`;
            } else {
                bEl.title = '';
            }
        }
    }

    const lEl = document.getElementById(`lvl-txt-${u.id}`);
    if(lEl) lEl.innerText = `[Lvl ${u.level}]`;

    // Update boost button
    const boostCostBtc = u.boostCost / btcPrice;
    const boostCostEl = document.getElementById(`boost-cost-${u.id}`);
    if(boostCostEl) boostCostEl.innerText = `$${Math.floor(u.boostCost).toLocaleString()}`;

    // Format the current yield amount (after all boosts applied)
    const currentYield = u.baseYield * u.level * Math.pow(1.10, u.boostLevel);
    const boostAmtEl = document.getElementById(`boost-amt-${u.id}`);
    if(boostAmtEl) {
        if (currentYield >= 1) {
            boostAmtEl.innerText = currentYield.toFixed(2);
        } else if (currentYield >= 0.0001) {
            boostAmtEl.innerText = (currentYield * 1000000).toFixed(0) + 'μ';
        } else if (currentYield > 0) {
            boostAmtEl.innerText = (currentYield * 1000000000).toFixed(0);
        } else {
            boostAmtEl.innerText = '0';
        }
    }

    const boostBtn = document.getElementById(`boost-${u.id}`);
    if(boostBtn) {
        boostBtn.disabled = (u.level === 0 || dollarBalance < u.boostCost);
        if (u.level === 0) {
            boostBtn.innerHTML = `Purchase ${u.name} first`;
        } else {
            boostBtn.innerHTML = `+10% HASH RATE | <span id="boost-cost-${u.id}">$${Math.floor(u.boostCost).toLocaleString()}</span>`;
        }
    }
});

// Update ETH upgrades display
ethUpgrades.forEach(u => {
    const costUsd = u.currentUsd;
    const yEl = document.getElementById(`eth-yield-${u.id}`);
    if (yEl) {
        if (u.isClickUpgrade) {
            yEl.innerText = `+10% MANUAL ETH RATE`;
        } else {
            const currentSpeed = u.baseYield * u.level * Math.pow(1.10, u.boostLevel);
            yEl.innerText = `+${currentSpeed.toFixed(8)} Ξ/s - Current Speed`;
        }
    }

    // Update per-level increase for ETH
    const ethIncreaseEl = document.getElementById(`eth-increase-${u.id}`);
    if (ethIncreaseEl) {
        if (u.isClickUpgrade) {
            ethIncreaseEl.style.display = 'none';
        } else {
            const perLevelIncrease = u.baseYield * Math.pow(1.10, u.boostLevel);
            ethIncreaseEl.innerText = `+${perLevelIncrease.toFixed(8)} Ξ/s per level`;
            ethIncreaseEl.style.display = 'block';
        }
    }

    const uEl = document.getElementById(`eth-usd-${u.id}`);
    if(uEl) uEl.innerText = `$${u.currentUsd.toLocaleString()}`;

    const affordEl = document.getElementById(`eth-afford-${u.id}`);
    if(affordEl) {
        let remaining = dollarBalance;
        let canAfford = 0;
        let nextCost = costUsd;
        let nextLevel = u.level;

        while (remaining >= nextCost) {
            remaining -= nextCost;
            canAfford++;
            nextLevel++;
            if (u.isClickUpgrade) {
                nextCost = u.baseUsd * Math.pow(1.75, nextLevel);
            } else {
                nextCost = u.baseUsd * Math.pow(1.15, nextLevel);
            }
        }

        affordEl.innerText = `x${canAfford}`;
        affordEl.style.color = canAfford > 0 ? '#00ff88' : '#666';
    }

    const bEl = document.getElementById(`eth-up-${u.id}`);
    if(bEl) {
        const hasEnoughDollars = dollarBalance >= costUsd;
        const powerReq = equipmentPowerReqs[u.id] || 0;
        const powerNeeded = totalPowerUsed + (powerReq * (u.level + 1));
        const hasEnoughPower = powerNeeded <= totalPowerAvailable || powerReq === 0;
        bEl.disabled = !(hasEnoughDollars && hasEnoughPower);

        // Change button appearance if power is insufficient
        if (!hasEnoughPower && powerReq > 0) {
            let overlay = bEl.querySelector('.power-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'power-overlay';
                overlay.style.position = 'absolute';
                overlay.style.inset = '0';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.style.background = 'rgba(0,0,0,0.8)';
                overlay.style.borderRadius = '10px';
                overlay.style.color = '#999';
                overlay.style.fontWeight = 'bold';
                overlay.style.fontSize = '1.1rem';
                overlay.style.textAlign = 'center';
                overlay.innerHTML = 'YOU NEED MORE POWER';
                bEl.style.position = 'relative';
                bEl.appendChild(overlay);
            }
            bEl.title = `Insufficient power! This requires ${powerReq.toLocaleString()}W per level. Need ${Math.ceil(powerNeeded - totalPowerAvailable).toLocaleString()}W more power capacity.`;
        } else {
            let overlay = bEl.querySelector('.power-overlay');
            if (overlay) overlay.remove();

            if (!hasEnoughDollars) {
                bEl.title = `Need $${(costUsd - dollarBalance).toLocaleString()} more`;
            } else {
                bEl.title = '';
            }
        }
    }

    const lEl = document.getElementById(`eth-lvl-txt-${u.id}`);
    if(lEl) lEl.innerText = `[Lvl ${u.level}]`;

    // Update ETH boost button
    const ethBoostBtn = document.getElementById(`eth-boost-${u.id}`);
    if(ethBoostBtn) {
        ethBoostBtn.disabled = (u.level === 0 || dollarBalance < u.boostCost);
        if (u.level === 0) {
            ethBoostBtn.innerHTML = `Purchase ${u.name} first`;
        } else {
            ethBoostBtn.innerHTML = `+10% HASH RATE | <span id="eth-boost-cost-${u.id}">$${Math.floor(u.boostCost).toLocaleString()}</span>`;
        }
    }
});

// Update DOGE upgrades display
dogeUpgrades.forEach(u => {
    const costUsd = u.currentUsd;
    const yEl = document.getElementById(`doge-yield-${u.id}`);
    if (yEl) {
        if (u.isClickUpgrade) {
            yEl.innerText = `+10% MANUAL DOGE RATE`;
        } else {
            const currentSpeed = u.baseYield * u.level * Math.pow(1.10, u.boostLevel);
            yEl.innerText = `+${currentSpeed.toFixed(8)} Ð/s - Current Speed`;
        }
    }

    // Update per-level increase for DOGE
    const dogeIncreaseEl = document.getElementById(`doge-increase-${u.id}`);
    if (dogeIncreaseEl) {
        if (u.isClickUpgrade) {
            dogeIncreaseEl.style.display = 'none';
        } else {
            const perLevelIncrease = u.baseYield * Math.pow(1.10, u.boostLevel);
            dogeIncreaseEl.innerText = `+${perLevelIncrease.toFixed(8)} Ð/s per level`;
            dogeIncreaseEl.style.display = 'block';
        }
    }

    const uEl = document.getElementById(`doge-usd-${u.id}`);
    if(uEl) uEl.innerText = `$${u.currentUsd.toLocaleString()}`;

    const affordEl = document.getElementById(`doge-afford-${u.id}`);
    if(affordEl) {
        let remaining = dollarBalance;
        let canAfford = 0;
        let nextCost = costUsd;
        let nextLevel = u.level;

        while (remaining >= nextCost) {
            remaining -= nextCost;
            canAfford++;
            nextLevel++;
            if (u.isClickUpgrade) {
                nextCost = u.baseUsd * Math.pow(1.75, nextLevel);
            } else {
                nextCost = u.baseUsd * Math.pow(1.15, nextLevel);
            }
        }

        affordEl.innerText = `x${canAfford}`;
        affordEl.style.color = canAfford > 0 ? '#00ff88' : '#666';
    }

    const bEl = document.getElementById(`doge-up-${u.id}`);
    if(bEl) {
        const hasEnoughDollars = dollarBalance >= costUsd;
        const powerReq = equipmentPowerReqs[u.id] || 0;
        const powerNeeded = totalPowerUsed + (powerReq * (u.level + 1));
        const hasEnoughPower = powerNeeded <= totalPowerAvailable || powerReq === 0;
        bEl.disabled = !(hasEnoughDollars && hasEnoughPower);

        // Change button appearance if power is insufficient
        if (!hasEnoughPower && powerReq > 0) {
            let overlay = bEl.querySelector('.power-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'power-overlay';
                overlay.style.position = 'absolute';
                overlay.style.inset = '0';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.style.background = 'rgba(0,0,0,0.8)';
                overlay.style.borderRadius = '10px';
                overlay.style.color = '#999';
                overlay.style.fontWeight = 'bold';
                overlay.style.fontSize = '1.1rem';
                overlay.style.textAlign = 'center';
                overlay.innerHTML = 'YOU NEED MORE POWER';
                bEl.style.position = 'relative';
                bEl.appendChild(overlay);
            }
            bEl.title = `Insufficient power! This requires ${powerReq.toLocaleString()}W per level. Need ${Math.ceil(powerNeeded - totalPowerAvailable).toLocaleString()}W more power capacity.`;
        } else {
            let overlay = bEl.querySelector('.power-overlay');
            if (overlay) overlay.remove();

            if (!hasEnoughDollars) {
                bEl.title = `Need $${(costUsd - dollarBalance).toLocaleString()} more`;
            } else {
                bEl.title = '';
            }
        }
    }

    const lEl = document.getElementById(`doge-lvl-txt-${u.id}`);
    if(lEl) lEl.innerText = `[Lvl ${u.level}]`;

    // Update DOGE boost button
    const dogeBoostBtn = document.getElementById(`doge-boost-${u.id}`);
    if(dogeBoostBtn) {
        dogeBoostBtn.disabled = (u.level === 0 || dollarBalance < u.boostCost);
        if (u.level === 0) {
            dogeBoostBtn.innerHTML = `Purchase ${u.name} first`;
        } else {
            dogeBoostBtn.innerHTML = `+10% HASH RATE | <span id="doge-boost-cost-${u.id}">$${Math.floor(u.boostCost).toLocaleString()}</span>`;
        }
    }
    });
    }

    setInterval(() => {
        const now = Date.now();
        const deltaTime = (now - lastTickTime) / 1000;
        lastTickTime = now;

        // BTC mining gains
        if (btcPerSec > 0) {
            let gain = btcPerSec * deltaTime;
            btcBalance += gain;
            btcLifetime += gain;
        }

        // ETH mining gains
        if (ethPerSec > 0) {
            let gain = ethPerSec * deltaTime;
            ethBalance += gain;
            ethLifetime += gain;
        }

        // DOGE mining gains
        if (dogePerSec > 0) {
            let gain = dogePerSec * deltaTime;
            dogeBalance += gain;
            dogeLifetime += gain;
        }

        updateUI();
        updateAutoClickerButtonState();
    }, 100);

    // Initialize all shops after DOM is ready
    function initializeGame() {
        initBtcShop();
        initEthShop();
        initDogeShop();
        initPowerShop();
        loadGame(); // This calls updateUI() internally
        updateAutoClickerButtonState(); // Update button state immediately after loading
        setBuyQuantity(1); // Highlight the 1x button on page load

        const canvasElement = document.getElementById('nwChart');
        console.log('Canvas element:', canvasElement);

        if (!canvasElement) {
            console.error('ERROR: Canvas element not found!');
            return;
        }

        const ctx = canvasElement.getContext('2d');
        console.log('Canvas context:', ctx);

        // Initialize chart with full history (at least one data point)
        const currentNetWorth = (btcBalance * btcPrice) + (ethBalance * ethPrice) + (dogeBalance * dogePrice);
        console.log('=== CHART DEBUG ===');
        console.log('btcBalance:', btcBalance, 'btcPrice:', btcPrice);
        console.log('ethBalance:', ethBalance, 'ethPrice:', ethPrice);
        console.log('dogeBalance:', dogeBalance, 'dogePrice:', dogePrice);
        console.log('hardwareEquity:', hardwareEquity);
        console.log('Current net worth for chart:', currentNetWorth);

        // Always start chart at 0
        if (chartHistory.length === 0) {
            chartHistory.push(0);
            chartHistory.push(0);
            chartTimestamps.push({ time: Date.now(), value: 0 });
            chartTimestamps.push({ time: Date.now() + 1000, value: 0 });
        }

        console.log('Chart history length:', chartHistory.length, 'Data:', chartHistory);

        // Check if Chart.js loaded
        if (typeof Chart === 'undefined') {
            console.error('ERROR: Chart.js library not loaded!');
            document.querySelector('.chart-wrapper').innerHTML = '<div style="color: red; padding: 20px;">ERROR: Chart.js failed to load. Check internet connection.</div>';
            return;
        }

        console.log('Chart.js version:', Chart.version);

        let nwChart;
        try {
            nwChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: chartHistory.map((_, i) => ''),
                datasets: [{
                    data: chartHistory,
                    borderColor: '#00ff88',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                scales: {
                    x: {
                        display: false,
                        grid: {
                            display: false,
                            drawBorder: false
                        },
                        ticks: {
                            display: false
                        }
                    },
                    y: {
                        display: true,
                        beginAtZero: true,
                        min: 0,
                        grace: '5%',
                        grid: {
                            display: false,
                            drawBorder: false
                        },
                        ticks: {
                            display: true,
                            color: '#999',
                            font: {
                                size: 10
                            },
                            maxTicksLimit: 8,
                            callback: function(value) {
                                if (value >= 1000) {
                                    return '$' + (value / 1000).toFixed(2) + 'k';
                                }
                                return '$' + value.toFixed(2);
                            }
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: { enabled: false }
                }
            }
        });

            console.log('Chart object created:', nwChart);
            console.log('Chart initialized with data:', chartHistory);
        } catch (error) {
            console.error('ERROR creating chart:', error);
            document.querySelector('.chart-wrapper').innerHTML = '<div style="color: red; padding: 20px;">ERROR: Failed to create chart - ' + error.message + '</div>';
            return;
        }

        let updateCount = 0;
        setInterval(() => {
            if (!nwChart) return;

            const netWorth = (btcBalance * btcPrice) + (ethBalance * ethPrice) + (dogeBalance * dogePrice);

            // Always update the chart with the current net worth
            chartHistory.push(netWorth);
            chartTimestamps.push({ time: Date.now(), value: netWorth });

            // Keep all data points - chart will stretch to the right showing full history
            // No limit on data points so we preserve the entire game history

            nwChart.data.datasets[0].data = chartHistory;
            nwChart.data.labels = chartHistory.map((_, i) => '');
            nwChart.update('none');

            updateCount++;
            if (updateCount % 5 === 0) {
                console.log('Chart updated:', updateCount, 'times. Current data points:', chartHistory.length, 'Latest value:', netWorth, 'BTC:', btcBalance, 'ETH:', ethBalance, 'DOGE:', dogeBalance);
            }
        }, 2000);

        // Auto-save every 1.5 seconds
        setInterval(saveGame, 1500);

    // Show offline earnings if applicable
    console.log('Checking for offline earnings:', window.offlineEarningsToShow);
    if (window.offlineEarningsToShow) {
        const hasEarnings = (window.offlineEarningsToShow.btc || 0) > 0 ||
                           (window.offlineEarningsToShow.eth || 0) > 0 ||
                           (window.offlineEarningsToShow.doge || 0) > 0;
        if (hasEarnings) {
            console.log('Showing offline earnings modal with:', window.offlineEarningsToShow);
            setTimeout(() => {
                showOfflineEarningsModal(
                    window.offlineEarningsToShow.btc || 0,
                    window.offlineEarningsToShow.eth || 0,
                    window.offlineEarningsToShow.doge || 0,
                    window.offlineEarningsToShow.seconds
                );
                window.offlineEarningsToShow = null;
            }, 300);
        } else {
            console.log('Offline earnings were all 0 or less');
        }
    } else {
        console.log('No offline earnings data stored');
    }

        // Start price swings: separate timing for each crypto
        // Only start if not already running (prevents multiple loops on refresh)
        if (!priceSwingsStarted) {
            priceSwingsStarted = true;
            // BTC swings (start immediately)
            btcTinySwing();       // ±0.05%-0.1% every 2 seconds
            btcFrequentSwing();   // ±0.1%-1% every 2-60 seconds
            btcBigSwing();        // ±2.5%-10% every 5-10 minutes

            // ETH swings (start with 700ms delay to stagger from BTC)
            setTimeout(ethTinySwing, 700);       // ±0.05%-0.1% every 2.3 seconds
            setTimeout(ethFrequentSwing, 1200);  // ±0.1%-1.2% every 3-75 seconds
            setTimeout(ethBigSwing, 1500);       // ±2.5%-12% every 4-12 minutes

            // DOGE swings (start with 1400ms delay to stagger from BTC and ETH)
            setTimeout(dogeTinySwing, 1400);     // ±0.05%-0.15% every 2.7 seconds
            setTimeout(dogeFrequentSwing, 2100); // ±0.15%-1.8% every 2-45 seconds
            setTimeout(dogeBigSwing, 2800);      // ±3%-18% every 3-8 minutes
        }
    }

    // Run initialization when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeGame);
    } else {
        initializeGame();
    }
</script>

</body>

</html>




